{
  "version": 3,
  "sources": ["../../../../../../node_modules/udsv/dist/uDSV.mjs"],
  "sourcesContent": ["/**\n* Copyright (c) 2024, Leon Sorokin\n* All rights reserved. (MIT Licensed)\n*\n* uDSV.js\n* A small, fast CSV parser\n* https://github.com/leeoniya/uDSV (v0.6.0)\n*/\n\nconst comma = ',';\nconst quote = '\"';\nconst tab = '\\t';\nconst pipe = '|';\nconst semi = ';';\nconst ISO8601 = /^\\d{4}-\\d{2}-\\d{2}(?:T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d{3,})?(?:Z|[-+]\\d{2}:?\\d{2}))?$/;\nconst BOOL_RE = /^(?:t(?:rue)?|f(?:alse)?|y(?:es)?|n(?:o)?|0|1)$/i;\nconst COL_DELIMS = [tab, pipe, semi, comma];\nconst CHUNK_SIZE = 1e3;\nfunction boolTrue(v) {\n  let [c0, c1 = ''] = v;\n  return c0 == '1' || c0 == '0' ? '1' : c0 == 't' || c0 == 'f' ? c1 == '' ? 't' : 'true' : c0 == 'T' || c0 == 'F' ? c1 == '' ? 'T' : c1 == 'R' || c1 === 'A' ? 'TRUE' : 'True' : c0 == 'y' || c0 == 'n' ? c1 == '' ? 'y' : 'yes' : c0 == 'Y' || c0 == 'N' ? c1 == '' ? 'Y' : c1 == 'E' || c1 === 'O' ? 'YES' : 'Yes' : '';\n}\nfunction isJSON(v) {\n  if (v[0] === '[' || v[0] === '{') {\n    try {\n      JSON.parse(v);\n      return true;\n    } catch {}\n  }\n  return false;\n}\nconst T_STRING = 's';\nconst T_DATE = 'd';\nconst T_NUMBER = 'n';\nconst T_JSON = 'j';\nconst T_BOOLEAN = 'b';\nfunction guessType(ci, rows) {\n  // row with a value to analyze\n  let row = rows.findLast(r => r[ci] !== '' && r[ci] !== 'null' && r[ci] !== 'NULL' && r[ci] !== 'NaN');\n  let t = T_STRING;\n  if (row != null) {\n    let v = row[ci];\n    t = ISO8601.test(v) ? T_DATE : +v === +v ? T_NUMBER : BOOL_RE.test(v) ? T_BOOLEAN + ':' + boolTrue(v) : isJSON(v) ? T_JSON : t;\n  }\n  return t;\n}\nconst toJSON = JSON.stringify;\nconst onlyStrEsc = v => typeof v === 'string' ? toJSON(v) : v;\nfunction getValParseExpr(ci, col) {\n  let {\n    type\n  } = col;\n  let rv = `r[${ci}]`;\n  let parseExpr = type === T_DATE ? `new Date(${rv})` : type === T_JSON ? `JSON.parse(${rv})` : type === T_NUMBER ? `+${rv}` : type[0] === T_BOOLEAN ? `${rv} === ${toJSON(type.slice(2))} ? true : false` : rv;\n  let {\n    repl\n  } = col;\n  let nanExpr = repl.NaN !== void 0 && type === T_NUMBER ? `${rv} === 'NaN' ? ${onlyStrEsc(repl.NaN)} : ` : '';\n  let nullExpr = repl.null !== void 0 ? `${rv} === 'null' || ${rv} === 'NULL' ? ${onlyStrEsc(repl.null)} : ` : '';\n  let emptyExpr = repl.empty !== void 0 ? `${rv} === '' ? ${onlyStrEsc(repl.empty)} : ` : '';\n  return `${emptyExpr} ${nullExpr} ${nanExpr} ${parseExpr}`;\n}\nconst segsRe = /\\w+(?:\\[|\\]?[\\.\\[]?|$)/gm;\nfunction genToTypedRows(cols, objs = false, deep = false) {\n  let buf = '';\n  if (objs && deep) {\n    let tplObj = {};\n    let colIdx = 0;\n    let paths = cols.map(c => c.name.replace(/\\.(\\d+)\\.?/gi, '[$1]'));\n    do {\n      let path = paths.shift();\n      let segs = /\\s/.test(path) ? [path] : [...path.matchAll(segsRe)].flatMap(m => m.map(m => m.replace(']', '')));\n      let node = tplObj;\n      do {\n        let seg = segs.shift();\n        let key = seg;\n        let endChar = seg.at(-1);\n        let hasKids = endChar == '.' || endChar == '[';\n        if (hasKids) {\n          key = seg.slice(0, -1);\n          let nextNode = node[key] ?? (endChar == '.' ? {} : []);\n          node = node[key] = nextNode;\n        } else node[key] = `¦${colIdx}¦`;\n      } while (segs.length > 0);\n      colIdx++;\n    } while (paths.length > 0);\n    buf = toJSON(tplObj).replace(/\"¦(\\d+)¦\"/g, (m, ci) => getValParseExpr(+ci, cols[+ci]));\n  } else {\n    if (!objs && cols.every(c => c.type === T_STRING)) buf = 'r';else {\n      buf = objs ? '{' : '[';\n      cols.forEach((col, ci) => {\n        buf += objs ? `${toJSON(col.name)}:` : '';\n        let parseVal = getValParseExpr(ci, col);\n        buf += `${parseVal},`;\n      });\n      buf += objs ? '}' : ']';\n    }\n  }\n  let fnBody = `\n\t\tlet arr = Array(rows.length);\n\n\t\tfor (let i = 0; i < rows.length; i++) {\n\t\t\tlet r = rows[i];\n\t\t\tarr[i] = ${buf};\n\t\t}\n\n\t\treturn arr;\n\t`;\n  let toObjFn = new Function('rows', fnBody);\n\n  // console.log(fnBody);\n  // console.log(toObjFn(chunk.slice(1, 5)));\n  // process.exit();\n\n  return toObjFn;\n}\nfunction genToCols(cols) {\n  return new Function('rows', `\n\t\tlet cols = [${cols.map(() => `Array(rows.length)`).join(',')}];\n\n\t\tfor (let i = 0; i < rows.length; i++) {\n\t\t\tlet r = rows[i];\n\t\t\t${cols.map((c, i) => `cols[${i}][i] = r[${i}]`).join(';')};\n\t\t}\n\n\t\treturn cols;\n\t`);\n}\n\n// https://www.loc.gov/preservation/digital/formats/fdd/fdd000323.shtml\nfunction inferSchema(csvStr, opts, maxRows) {\n  let {\n    header: headerFn,\n    col: colDelim,\n    row: rowDelim,\n    encl: colEncl,\n    esc: escEncl,\n    //\tomit,  // #comments and empty lines (ignore:), needs callback for empty and comments?\n    trim = false\n  } = opts ?? {};\n\n  // by default, grab first row, and skip it\n  headerFn ??= firstRows => [firstRows[0]];\n  maxRows ??= 10;\n\n  // will fail if header contains line breaks in quoted value\n  // will fail if single line without line breaks\n  const rowRE = new RegExp(`(.*)(${rowDelim ?? '\\r\\n|\\r|\\n'})`);\n  const firstRowMatch = csvStr.match(rowRE);\n  const firstRowStr = firstRowMatch[1];\n  rowDelim ??= firstRowMatch[2];\n  colDelim ??= COL_DELIMS.find(delim => firstRowStr.indexOf(delim) > -1) ?? comma;\n  const schema = {\n    skip: 1,\n    // how many header rows to skip\n    col: colDelim,\n    row: rowDelim,\n    encl: colEncl,\n    esc: escEncl,\n    trim: trim,\n    cols: []\n  };\n  const _maxCols = firstRowStr.split(colDelim).length;\n  const firstRows = [];\n  parse(csvStr, schema, chunk => {\n    firstRows.push(...chunk);\n  }, 0, true, maxRows, 1, _maxCols);\n  let headerRows = headerFn(firstRows) ?? [];\n  let skip = schema.skip = headerRows.length;\n\n  // first non-null row\n  let colNames = headerRows.find(row => row != null) ?? [...Array(firstRows[0].length).keys()];\n  firstRows.splice(0, skip);\n  colNames.forEach((colName, colIdx) => {\n    let type = guessType(colIdx, firstRows);\n    let col = {\n      name: colName,\n      type,\n      // this could be type-dependant (e.g. {empty: 0, null: 0, NaN: NaN} for numbers)\n      repl: {\n        empty: null,\n        NaN: void 0,\n        null: void 0\n      }\n    };\n    schema.cols.push(col);\n  });\n  return schema;\n}\nfunction initParser(schema, chunkSize) {\n  let {\n    skip,\n    cols\n  } = schema;\n  let _toStrs = null;\n  let _toArrs = null;\n  let _toObjs = null;\n  let _toDeep = null;\n  let _toObjsS = null;\n  let _toCols = null;\n  let streamChunkNum = 0;\n  let streamState = 0;\n  let streamParse = null;\n  let streamCb = null;\n  let pendChunk = '';\n  let prevUnparsed = '';\n  let buf = null;\n  function reset() {\n    streamState = streamChunkNum = 0;\n    prevUnparsed = pendChunk = '';\n    streamParse = streamCb = buf = null;\n  }\n  let accum = (rows, add) => {\n    add(rows);\n  };\n  let initRows = () => [];\n  let initCols = () => cols.map(c => []);\n  let addRows = rows => {\n    buf.push(...rows);\n  };\n  let addCols = cols => {\n    cols.forEach((vals, ci) => {\n      buf[ci].push(...vals);\n    });\n  };\n  function gen(accInit, accAppend, genConvertRows) {\n    let convertRows = null;\n    return (csvStr, cb = accum) => {\n      convertRows ??= genConvertRows();\n      buf ??= accInit();\n      let out = buf;\n      let withEOF = streamState === 0 || streamState === 2;\n      let _skip = streamChunkNum === 0 ? skip : 0;\n      parse(csvStr, schema, (rows, partial) => {\n        prevUnparsed = partial;\n        let res = cb(convertRows(rows), accAppend);\n        if (res === false && streamState !== 0) reset();\n        return res;\n      }, _skip, withEOF, chunkSize);\n      if (withEOF) buf = null;\n      return out;\n    };\n  }\n  const stringArrs = gen(initRows, addRows, () => {\n    _toStrs ??= rows => rows;\n    return _toStrs;\n  });\n  const stringObjs = gen(initRows, addRows, () => {\n    _toObjsS ??= genToTypedRows(cols.map(col => ({\n      ...col,\n      type: 's',\n      repl: {\n        ...col.repl,\n        empty: void 0\n      }\n    })), true, false);\n    return _toObjsS;\n  });\n  const typedArrs = gen(initRows, addRows, () => {\n    _toArrs ??= genToTypedRows(cols, false, false);\n    return _toArrs;\n  });\n  const typedObjs = gen(initRows, addRows, () => {\n    _toObjs ??= genToTypedRows(cols, true, false);\n    return _toObjs;\n  });\n  const typedDeep = gen(initRows, addRows, () => {\n    _toDeep ??= genToTypedRows(cols, true, true);\n    return _toDeep;\n  });\n  const typedCols = gen(initCols, addCols, () => {\n    _toArrs ??= genToTypedRows(cols, false, false);\n    _toCols ??= genToCols(cols);\n    return rows => _toCols(_toArrs(rows));\n  });\n  return {\n    schema,\n    stringArrs,\n    stringObjs,\n    typedArrs,\n    typedObjs,\n    typedDeep,\n    typedCols,\n    chunk(csvStr, parse = stringArrs, cb = accum) {\n      streamParse ??= parse;\n      streamCb ??= cb;\n      if (streamState === 1) {\n        streamParse(prevUnparsed + pendChunk, streamCb);\n        streamChunkNum++;\n      }\n      pendChunk = csvStr;\n      streamState = 1;\n    },\n    end() {\n      streamState = 2;\n      let out = streamParse(prevUnparsed + pendChunk, streamCb);\n      reset();\n      return out;\n    }\n  };\n}\nfunction parse(csvStr, schema, cb, skip = 0, withEOF = true, chunkSize = CHUNK_SIZE, chunkLimit = null, _maxCols = null) {\n  let {\n    row: rowDelim,\n    col: colDelim,\n    encl: colEncl,\n    esc: escEncl,\n    trim\n  } = schema;\n  colEncl ??= csvStr.indexOf(quote) > -1 ? quote : ''; // TODO: detect single quotes?\n  escEncl ??= colEncl;\n  let replEsc = `${escEncl}${colEncl}`;\n  let numCols = _maxCols || schema.cols.length;\n  let _limit = chunkLimit != null;\n  // uses a slower regexp path for schema probing\n  let _probe = _maxCols != null && _limit;\n  let rowDelimLen = rowDelim.length;\n  let colDelimLen = colDelim.length;\n  let colEnclChar = colEncl.charCodeAt(0);\n  let escEnclChar = escEncl.charCodeAt(0);\n  let rowDelimChar = rowDelim.charCodeAt(0);\n  let colDelimChar = colDelim.charCodeAt(0);\n  let spaceChar = 32;\n  let numChunks = 0;\n  let pos = 0;\n  let endPos = csvStr.length - 1;\n  let linePos = 0;\n  let rows = [];\n  let rowTpl = Array(numCols).fill('');\n  let row = rowTpl.slice();\n  let colIdx = 0;\n  let lastColIdx = numCols - 1;\n  let filledColIdx = -1;\n  if (colEncl === '') {\n    while (pos <= endPos) {\n      if (colIdx === lastColIdx) {\n        let pos2 = csvStr.indexOf(rowDelim, pos);\n        if (pos2 === -1) {\n          if (!withEOF) break;\n          pos2 = endPos + 1;\n        }\n        let s = csvStr.slice(pos, pos2);\n        row[colIdx] = trim ? s.trim() : s;\n        --skip < 0 && rows.push(row);\n        if (rows.length === chunkSize) {\n          let stop = cb(rows, '') === false;\n          rows = [];\n          if (stop || _limit && ++numChunks === chunkLimit) return;\n        }\n        row = rowTpl.slice();\n        colIdx = 0;\n        filledColIdx = -1;\n        pos = pos2 + rowDelimLen;\n        linePos = pos;\n      } else {\n        // empty line\n        if (colIdx === 0 && csvStr.charCodeAt(pos) === rowDelimChar) {\n          pos += rowDelimLen;\n          // TODO: callback here!\n        } else {\n          let pos2 = csvStr.indexOf(colDelim, pos);\n          if (pos2 === -1) {\n            if (!withEOF) break;\n          }\n          let s = csvStr.slice(pos, pos2);\n          row[colIdx] = trim ? s.trim() : s;\n          pos = pos2 + colDelimLen;\n          filledColIdx = colIdx++;\n        }\n      }\n    }\n    if (withEOF && colIdx === lastColIdx && filledColIdx > -1) --skip < 0 && rows.push(row);\n    if (!withEOF || rows.length > 0) cb(rows, !withEOF ? csvStr.slice(linePos) : '');\n    return;\n  }\n\n  // should this be * to handle ,, ?\n  const takeToCommaOrEOL = _probe ? new RegExp(`[^${colDelim}${rowDelim}]+`, 'my') : null;\n\n  // 0 = no\n  // 1 = unquoted\n  // 2 = quoted\n  let inCol = 0;\n  let v = '';\n  let c = 0;\n  let pos0 = pos;\n  while (pos <= endPos) {\n    c = csvStr.charCodeAt(pos);\n    if (inCol === 0) {\n      if (c === colEnclChar) {\n        inCol = 2;\n        pos += 1;\n        pos0 = pos;\n        if (pos > endPos) break;\n        c = csvStr.charCodeAt(pos);\n      } else if (c === colDelimChar || c === rowDelimChar) {\n        // PUSH MACRO START\n        if (c === rowDelimChar && colIdx === 0) {\n          pos += rowDelimLen;\n          // TODO: callback here!\n          continue;\n        }\n        row[colIdx] = v;\n        filledColIdx = colIdx;\n        colIdx += 1;\n        pos += 1;\n        v = '';\n        if (c === rowDelimChar) {\n          if (_probe && filledColIdx < lastColIdx && rows.length === 0) {\n            row.length = rowTpl.length = filledColIdx + 1;\n            lastColIdx = filledColIdx;\n          }\n          --skip < 0 && rows.push(row);\n          if (rows.length === chunkSize) {\n            let stop = cb(rows, '') === false;\n            rows = [];\n            if (stop || _limit && ++numChunks === chunkLimit) return;\n          }\n          row = rowTpl.slice();\n          colIdx = 0;\n          filledColIdx = -1;\n          pos += rowDelimLen - 1;\n          linePos = pos;\n        }\n        // PUSH MACRO END\n\n        if (pos > endPos) break;\n      } else {\n        if (trim && c === spaceChar) {\n          while (c === spaceChar) c = csvStr.charCodeAt(++pos);\n        } else inCol = 1;\n      }\n    }\n    if (inCol === 2) {\n      let shouldRep = false;\n      let posTo = 0;\n      while (true) {\n        if (c === colEnclChar) {\n          if (colEnclChar === escEnclChar) {\n            if (pos + 1 > endPos) {\n              // TODO: test with chunk ending in closing \", even at EOL but not EOF\n              posTo = pos;\n              pos = endPos + 1;\n              break;\n            }\n            let cNext = csvStr.charCodeAt(pos + 1);\n            if (cNext === colEnclChar) {\n              pos += 2;\n\n              // MACRO START\n              shouldRep = true;\n              if (pos > endPos) break;\n              c = csvStr.charCodeAt(pos);\n              // MACRO END\n            } else {\n              inCol = 0;\n              posTo = pos;\n              pos += 1;\n              break;\n            }\n          } else {\n            let cPrev = csvStr.charCodeAt(pos - 1);\n            if (cPrev === escEnclChar) {\n              pos += 1;\n\n              // MACRO START\n              shouldRep = true;\n              if (pos > endPos) break;\n              c = csvStr.charCodeAt(pos);\n              // MACRO END\n            } else {\n              inCol = 0;\n              posTo = pos;\n              pos += 1;\n              break;\n            }\n          }\n        } else {\n          let pos2 = csvStr.indexOf(colEncl, pos);\n          if (pos2 === -1) {\n            pos = endPos + 1;\n            break;\n          }\n          pos = pos2;\n          c = colEnclChar;\n        }\n      }\n      if (inCol === 0 || pos > endPos) {\n        v = shouldRep ? csvStr.slice(pos0, posTo).replaceAll(replEsc, colEncl) : csvStr.slice(pos0, posTo);\n      }\n    } else if (inCol === 1) {\n      if (c === colDelimChar || c === rowDelimChar) {\n        // PUSH MACRO START\n        if (c === rowDelimChar && colIdx === 0) {\n          pos += rowDelimLen;\n          // TODO: callback here!\n          continue;\n        }\n        row[colIdx] = v;\n        filledColIdx = colIdx;\n        colIdx += 1;\n        pos += 1;\n        v = '';\n        if (c === rowDelimChar) {\n          if (_probe && filledColIdx < lastColIdx && rows.length === 0) {\n            row.length = rowTpl.length = filledColIdx + 1;\n            lastColIdx = filledColIdx;\n          }\n          --skip < 0 && rows.push(row);\n          if (rows.length === chunkSize) {\n            let stop = cb(rows, '') === false;\n            rows = [];\n            if (stop || _limit && ++numChunks === chunkLimit) return;\n          }\n          row = rowTpl.slice();\n          colIdx = 0;\n          filledColIdx = -1;\n          pos += rowDelimLen - 1;\n          linePos = pos;\n        }\n        // PUSH MACRO END\n\n        inCol = 0;\n      } else {\n        if (_probe) {\n          takeToCommaOrEOL.lastIndex = pos;\n          let m = takeToCommaOrEOL.exec(csvStr)[0];\n          v = m;\n          pos += m.length; // rowdelim when - 1\n        } else {\n          let pos2 = csvStr.indexOf(colIdx === lastColIdx ? rowDelim : colDelim, pos);\n          if (pos2 === -1) pos2 = endPos + 1;\n          let s = csvStr.slice(pos, pos2);\n          v = trim ? s.trim() : s;\n          pos = pos2;\n        }\n      }\n    }\n  }\n  if (withEOF && colIdx === lastColIdx) {\n    row[colIdx] = v;\n    --skip < 0 && rows.push(row);\n    inCol = 0;\n  }\n  let partial = !withEOF && (inCol !== 0 || (filledColIdx === -1 ? v !== '' :\n  // partial first col OR\n  filledColIdx < lastColIdx // not all cols filled\n  ));\n  cb(rows, partial ? csvStr.slice(linePos) : '');\n}\n\n// const parsed = {\n// \tformat: '',\n// \tdata: []\n// };\n\nexport { inferSchema, initParser };"],
  "mappings": "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",
  "names": ["m", "firstRows", "cols", "parse"]
}
