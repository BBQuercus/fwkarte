{
  "version": 3,
  "sources": ["../../../../../../../../node_modules/ol/reproj.js", "../../../../../../../../node_modules/ol/reproj/common.js", "../../../../../../../../node_modules/ol/reproj/Triangulation.js"],
  "sourcesContent": ["/**\n * @module ol/reproj\n */\nimport { containsCoordinate, createEmpty, extend, forEachCorner, getCenter, getHeight, getTopLeft, getWidth } from './extent.js';\nimport { createCanvasContext2D, releaseCanvas } from './dom.js';\nimport { getPointResolution, transform } from './proj.js';\nimport { solveLinearSystem } from './math.js';\nlet brokenDiagonalRendering_;\n\n/**\n * @type {Array<HTMLCanvasElement>}\n */\nexport const canvasPool = [];\n\n/**\n * This draws a small triangle into a canvas by setting the triangle as the clip region\n * and then drawing a (too large) rectangle\n *\n * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle\n * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.\n * @param {number} v1 The y-coordinate of the second point.\n * @param {number} u2 The x-coordinate of the third point.\n * @param {number} v2 The y-coordinate of the third point.\n */\nfunction drawTestTriangle(ctx, u1, v1, u2, v2) {\n  ctx.beginPath();\n  ctx.moveTo(0, 0);\n  ctx.lineTo(u1, v1);\n  ctx.lineTo(u2, v2);\n  ctx.closePath();\n  ctx.save();\n  ctx.clip();\n  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));\n  ctx.restore();\n}\n\n/**\n * Given the data from getImageData, see if the right values appear at the provided offset.\n * Returns true if either the color or transparency is off\n *\n * @param {Uint8ClampedArray} data The data returned from getImageData\n * @param {number} offset The pixel offset from the start of data.\n * @return {boolean} true if the diagonal rendering is broken\n */\nfunction verifyBrokenDiagonalRendering(data, offset) {\n  // the values ought to be close to the rgba(210, 0, 0, 0.75)\n  return Math.abs(data[offset * 4] - 210) > 2 || Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2;\n}\n\n/**\n * Determines if the current browser configuration can render triangular clip regions correctly.\n * This value is cached so the function is only expensive the first time called.\n * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976\n * Chrome works, and everything seems to work on OSX and Android. This function caches the\n * result. I suppose that it is conceivably possible that a browser might flip modes while the app is\n * running, but lets hope not.\n *\n * @return {boolean} true if the Diagonal Rendering is broken.\n */\nfunction isBrokenDiagonalRendering() {\n  if (brokenDiagonalRendering_ === undefined) {\n    const ctx = createCanvasContext2D(6, 6, canvasPool);\n    ctx.globalCompositeOperation = 'lighter';\n    ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';\n    drawTestTriangle(ctx, 4, 5, 4, 0);\n    drawTestTriangle(ctx, 4, 5, 0, 5);\n    const data = ctx.getImageData(0, 0, 3, 3).data;\n    brokenDiagonalRendering_ = verifyBrokenDiagonalRendering(data, 0) || verifyBrokenDiagonalRendering(data, 4) || verifyBrokenDiagonalRendering(data, 8);\n    releaseCanvas(ctx);\n    canvasPool.push(ctx.canvas);\n  }\n  return brokenDiagonalRendering_;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./coordinate.js\").Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {\n  const sourceCenter = transform(targetCenter, targetProj, sourceProj);\n\n  // calculate the ideal resolution of the source data\n  let sourceResolution = getPointResolution(targetProj, targetResolution, targetCenter);\n  const targetMetersPerUnit = targetProj.getMetersPerUnit();\n  if (targetMetersPerUnit !== undefined) {\n    sourceResolution *= targetMetersPerUnit;\n  }\n  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n  if (sourceMetersPerUnit !== undefined) {\n    sourceResolution /= sourceMetersPerUnit;\n  }\n\n  // Based on the projection properties, the point resolution at the specified\n  // coordinates may be slightly different. We need to reverse-compensate this\n  // in order to achieve optimal results.\n\n  const sourceExtent = sourceProj.getExtent();\n  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\n    const compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) / sourceResolution;\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\n      sourceResolution /= compensationFactor;\n    }\n  }\n  return sourceResolution;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {\n  const targetCenter = getCenter(targetExtent);\n  let sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);\n  if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n    forEachCorner(targetExtent, function (corner) {\n      sourceResolution = calculateSourceResolution(sourceProj, targetProj, corner, targetResolution);\n      return isFinite(sourceResolution) && sourceResolution > 0;\n    });\n  }\n  return sourceResolution;\n}\n\n/**\n * @typedef {Object} ImageExtent\n * @property {import(\"./extent.js\").Extent} extent Extent.\n * @property {import(\"./extent.js\").Extent} [clipExtent] Clip extent.\n * @property {import('./DataTile.js').ImageLike} image Image.\n */\n\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {import(\"./extent.js\").Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent.\n * @param {import(\"./reproj/Triangulation.js\").default} triangulation Calculated triangulation.\n * @param {Array<ImageExtent>} sources Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean} [renderEdges] Render reprojection edges.\n * @param {boolean} [interpolate] Use linear interpolation when resampling.\n * @param {boolean} [drawSingle] Draw single source images directly without stitchContext.\n * @param {boolean} [clipExtent] Clip stitchContext to sourceExtent.\n * @return {HTMLCanvasElement} Canvas with reprojected data.\n */\nexport function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, renderEdges, interpolate, drawSingle, clipExtent) {\n  const context = createCanvasContext2D(Math.round(pixelRatio * width), Math.round(pixelRatio * height), canvasPool);\n  if (!interpolate) {\n    context.imageSmoothingEnabled = false;\n  }\n  if (sources.length === 0) {\n    return context.canvas;\n  }\n  context.scale(pixelRatio, pixelRatio);\n  function pixelRound(value) {\n    return Math.round(value * pixelRatio) / pixelRatio;\n  }\n  context.globalCompositeOperation = 'lighter';\n  const sourceDataExtent = createEmpty();\n  sources.forEach(function (src, i, arr) {\n    extend(sourceDataExtent, src.extent);\n  });\n  let stitchContext;\n  const stitchScale = pixelRatio / sourceResolution;\n  // Round up Float32 scale values to prevent interpolation in Firefox.\n  const inverseScale = (interpolate ? 1 : 1 + Math.pow(2, -24)) / stitchScale;\n  if (!drawSingle || sources.length !== 1 || gutter !== 0) {\n    stitchContext = createCanvasContext2D(Math.round(getWidth(sourceDataExtent) * stitchScale), Math.round(getHeight(sourceDataExtent) * stitchScale), canvasPool);\n    if (!interpolate) {\n      stitchContext.imageSmoothingEnabled = false;\n    }\n    if (sourceExtent && clipExtent) {\n      const xPos = (sourceExtent[0] - sourceDataExtent[0]) * stitchScale;\n      const yPos = -(sourceExtent[3] - sourceDataExtent[3]) * stitchScale;\n      const width = getWidth(sourceExtent) * stitchScale;\n      const height = getHeight(sourceExtent) * stitchScale;\n      stitchContext.rect(xPos, yPos, width, height);\n      stitchContext.clip();\n    }\n    sources.forEach(function (src, i, arr) {\n      // This test should never fail -- but it does. Need to find a fix the upstream condition\n      if (src.image.width > 0 && src.image.height > 0) {\n        if (src.clipExtent) {\n          stitchContext.save();\n          const xPos = (src.clipExtent[0] - sourceDataExtent[0]) * stitchScale;\n          const yPos = -(src.clipExtent[3] - sourceDataExtent[3]) * stitchScale;\n          const width = getWidth(src.clipExtent) * stitchScale;\n          const height = getHeight(src.clipExtent) * stitchScale;\n          stitchContext.rect(interpolate ? xPos : Math.round(xPos), interpolate ? yPos : Math.round(yPos), interpolate ? width : Math.round(xPos + width) - Math.round(xPos), interpolate ? height : Math.round(yPos + height) - Math.round(yPos));\n          stitchContext.clip();\n        }\n        const xPos = (src.extent[0] - sourceDataExtent[0]) * stitchScale;\n        const yPos = -(src.extent[3] - sourceDataExtent[3]) * stitchScale;\n        const srcWidth = getWidth(src.extent) * stitchScale;\n        const srcHeight = getHeight(src.extent) * stitchScale;\n        stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, interpolate ? xPos : Math.round(xPos), interpolate ? yPos : Math.round(yPos), interpolate ? srcWidth : Math.round(xPos + srcWidth) - Math.round(xPos), interpolate ? srcHeight : Math.round(yPos + srcHeight) - Math.round(yPos));\n        if (src.clipExtent) {\n          stitchContext.restore();\n        }\n      }\n    });\n  }\n  const targetTopLeft = getTopLeft(targetExtent);\n  triangulation.getTriangles().forEach(function (triangle, i, arr) {\n    /* Calculate affine transform (src -> dst)\n     * Resulting matrix can be used to transform coordinate\n     * from `sourceProjection` to destination pixels.\n     *\n     * To optimize number of context calls and increase numerical stability,\n     * we also do the following operations:\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\n     *\n     * Src points: xi, yi\n     * Dst points: ui, vi\n     * Affine coefficients: aij\n     *\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n     */\n    const source = triangle.source;\n    const target = triangle.target;\n    let x0 = source[0][0],\n      y0 = source[0][1];\n    let x1 = source[1][0],\n      y1 = source[1][1];\n    let x2 = source[2][0],\n      y2 = source[2][1];\n    // Make sure that everything is on pixel boundaries\n    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);\n    const v0 = pixelRound(-(target[0][1] - targetTopLeft[1]) / targetResolution);\n    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);\n    const v1 = pixelRound(-(target[1][1] - targetTopLeft[1]) / targetResolution);\n    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);\n    const v2 = pixelRound(-(target[2][1] - targetTopLeft[1]) / targetResolution);\n\n    // Shift all the source points to improve numerical stability\n    // of all the subsequent calculations. The [x0, y0] is used here.\n    // This is also used to simplify the linear system.\n    const sourceNumericalShiftX = x0;\n    const sourceNumericalShiftY = y0;\n    x0 = 0;\n    y0 = 0;\n    x1 -= sourceNumericalShiftX;\n    y1 -= sourceNumericalShiftY;\n    x2 -= sourceNumericalShiftX;\n    y2 -= sourceNumericalShiftY;\n    const augmentedMatrix = [[x1, y1, 0, 0, u1 - u0], [x2, y2, 0, 0, u2 - u0], [0, 0, x1, y1, v1 - v0], [0, 0, x2, y2, v2 - v0]];\n    const affineCoefs = solveLinearSystem(augmentedMatrix);\n    if (!affineCoefs) {\n      return;\n    }\n    context.save();\n    context.beginPath();\n    if (isBrokenDiagonalRendering() || !interpolate) {\n      // Make sure that all lines are horizontal or vertical\n      context.moveTo(u1, v1);\n      // This is the diagonal line. Do it in 4 steps\n      const steps = 4;\n      const ud = u0 - u1;\n      const vd = v0 - v1;\n      for (let step = 0; step < steps; step++) {\n        // Go horizontally\n        context.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound(step * vd / (steps - 1)));\n        // Go vertically\n        if (step != steps - 1) {\n          context.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound((step + 1) * vd / (steps - 1)));\n        }\n      }\n      // We are almost at u0r, v0r\n      context.lineTo(u2, v2);\n    } else {\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n    }\n    context.clip();\n    context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);\n    context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);\n    let image;\n    if (stitchContext) {\n      image = stitchContext.canvas;\n      context.scale(inverseScale, -inverseScale);\n    } else {\n      const source = sources[0];\n      const extent = source.extent;\n      image = source.image;\n      context.scale(getWidth(extent) / image.width, -getHeight(extent) / image.height);\n    }\n    context.drawImage(image, 0, 0);\n    context.restore();\n  });\n  if (stitchContext) {\n    releaseCanvas(stitchContext);\n    canvasPool.push(stitchContext.canvas);\n  }\n  if (renderEdges) {\n    context.save();\n    context.globalCompositeOperation = 'source-over';\n    context.strokeStyle = 'black';\n    context.lineWidth = 1;\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n      const target = triangle.target;\n      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n      context.beginPath();\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n      context.closePath();\n      context.stroke();\n    });\n    context.restore();\n  }\n  return context.canvas;\n}", "/**\n * @module ol/reproj/common\n */\n\n/**\n * Default maximum allowed threshold  (in pixels) for reprojection\n * triangulation.\n * @type {number}\n */\nexport const ERROR_THRESHOLD = 0.5;", "/**\n * @module ol/reproj/Triangulation\n */\nimport { apply as applyMatrix } from '../transform.js';\nimport { boundingExtent, createEmpty, extendCoordinate, getArea, getBottomLeft, getBottomRight, getTopLeft, getTopRight, getWidth, intersects } from '../extent.js';\nimport { createTransformFromCoordinateTransform, getTransform, transform } from '../proj.js';\nimport { modulo } from '../math.js';\n\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\n */\n\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nconst MAX_SUBDIVISION = 10;\n\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nconst MAX_TRIANGLE_WIDTH = 0.25;\n\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nclass Triangulation {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\n   * @param {number} errorThreshold Acceptable error (in source units).\n   * @param {?number} destinationResolution The (optional) resolution of the destination.\n   * @param {import(\"../transform.js\").Transform} [sourceMatrix] Source transform matrix.\n   */\n  constructor(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, destinationResolution, sourceMatrix) {\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.sourceProj_ = sourceProj;\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.targetProj_ = targetProj;\n\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n    let transformInvCache = {};\n    const transformInv = sourceMatrix ? createTransformFromCoordinateTransform(input => applyMatrix(sourceMatrix, transform(input, this.targetProj_, this.sourceProj_))) : getTransform(this.targetProj_, this.sourceProj_);\n\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n     * @private\n     */\n    this.transformInv_ = function (c) {\n      const key = c[0] + '/' + c[1];\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c);\n      }\n      return transformInvCache[key];\n    };\n\n    /**\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n\n    /**\n     * @type {Array<Triangle>}\n     * @private\n     */\n    this.triangles_ = [];\n\n    /**\n     * Indicates that the triangulation crosses edge of the source projection.\n     * @type {boolean}\n     * @private\n     */\n    this.wrapsXInSource_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && getWidth(maxSourceExtent) >= getWidth(this.sourceProj_.getExtent());\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? getWidth(this.sourceProj_.getExtent()) : null;\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.targetWorldWidth_ = this.targetProj_.getExtent() ? getWidth(this.targetProj_.getExtent()) : null;\n    const destinationTopLeft = getTopLeft(targetExtent);\n    const destinationTopRight = getTopRight(targetExtent);\n    const destinationBottomRight = getBottomRight(targetExtent);\n    const destinationBottomLeft = getBottomLeft(targetExtent);\n    const sourceTopLeft = this.transformInv_(destinationTopLeft);\n    const sourceTopRight = this.transformInv_(destinationTopRight);\n    const sourceBottomRight = this.transformInv_(destinationBottomRight);\n    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n\n    /*\n     * The maxSubdivision controls how many splittings of the target area can\n     * be done. The idea here is to do a linear mapping of the target areas\n     * but the actual overall reprojection (can be) extremely non-linear. The\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n     * tile size. However this function is also called to remap canvas rendered\n     * layers which can be much larger. This calculation increases the maxSubdivision\n     * value by the right factor so that each 256x256 pixel area has\n     * MAX_SUBDIVISION divisions.\n     */\n    const maxSubdivision = MAX_SUBDIVISION + (destinationResolution ? Math.max(0, Math.ceil(Math.log2(getArea(targetExtent) / (destinationResolution * destinationResolution * 256 * 256)))) : 0);\n    this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);\n    if (this.wrapsXInSource_) {\n      let leftBound = Infinity;\n      this.triangles_.forEach(function (triangle, i, arr) {\n        leftBound = Math.min(leftBound, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);\n      });\n\n      // Shift triangles to be as close to `leftBound` as possible\n      // (if the distance is more than `worldWidth / 2` it can be closer.\n      this.triangles_.forEach(triangle => {\n        if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {\n          const newTriangle = [[triangle.source[0][0], triangle.source[0][1]], [triangle.source[1][0], triangle.source[1][1]], [triangle.source[2][0], triangle.source[2][1]]];\n          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[0][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[1][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[2][0] -= this.sourceWorldWidth_;\n          }\n\n          // Rarely (if the extent contains both the dateline and prime meridian)\n          // the shift can in turn break some triangles.\n          // Detect this here and don't shift in such cases.\n          const minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n          const maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n          if (maxX - minX < this.sourceWorldWidth_ / 2) {\n            triangle.source = newTriangle;\n          }\n        }\n      });\n    }\n    transformInvCache = {};\n  }\n\n  /**\n   * Adds triangle to the triangulation.\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @private\n   */\n  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\n    this.triangles_.push({\n      source: [aSrc, bSrc, cSrc],\n      target: [a, b, c]\n    });\n  }\n\n  /**\n   * Adds quad (points in clock-wise order) to the triangulation\n   * (and reprojects the vertices) if valid.\n   * Performs quad subdivision if needed to increase precision.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n   * @private\n   */\n  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n    const sourceCoverageX = this.sourceWorldWidth_ ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;\n    const sourceWorldWidth = /** @type {number} */this.sourceWorldWidth_;\n\n    // when the quad is wrapped in the source projection\n    // it covers most of the projection extent, but not fully\n    const wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;\n    let needsSubdivision = false;\n    if (maxSubdivision > 0) {\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n        const targetQuadExtent = boundingExtent([a, b, c, d]);\n        const targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;\n        needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n        needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n    }\n    if (!needsSubdivision && this.maxSourceExtent_) {\n      if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n          // whole quad outside source projection extent -> ignore\n          return;\n        }\n      }\n    }\n    let isNotFinite = 0;\n    if (!needsSubdivision) {\n      if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {\n        if (maxSubdivision > 0) {\n          needsSubdivision = true;\n        } else {\n          // It might be the case that only 1 of the points is infinite. In this case\n          // we can draw a single triangle with the other three points\n          isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n          if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) {\n            return;\n          }\n        }\n      }\n    }\n    if (maxSubdivision > 0) {\n      if (!needsSubdivision) {\n        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n        const centerSrc = this.transformInv_(center);\n        let dx;\n        if (wrapsX) {\n          const centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) + modulo(cSrc[0], sourceWorldWidth)) / 2;\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n        } else {\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n        }\n        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n        const centerSrcErrorSquared = dx * dx + dy * dy;\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n      }\n      if (needsSubdivision) {\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n          // split horizontally (top & bottom)\n          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n          const bcSrc = this.transformInv_(bc);\n          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n          const daSrc = this.transformInv_(da);\n          this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);\n          this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);\n        } else {\n          // split vertically (left & right)\n          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n          const abSrc = this.transformInv_(ab);\n          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n          const cdSrc = this.transformInv_(cd);\n          this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);\n          this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);\n        }\n        return;\n      }\n    }\n    if (wrapsX) {\n      if (!this.canWrapXInSource_) {\n        return;\n      }\n      this.wrapsXInSource_ = true;\n    }\n\n    // Exactly zero or one of *Src is not finite\n    // The triangles must have the diagonal line as the first side\n    // This is to allow easy code in reproj.s to make it straight for broken\n    // browsers that can't handle diagonal clipping\n    if ((isNotFinite & 0xb) == 0) {\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n    }\n    if ((isNotFinite & 0xe) == 0) {\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n    }\n    if (isNotFinite) {\n      // Try the other two triangles\n      if ((isNotFinite & 0xd) == 0) {\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n      }\n      if ((isNotFinite & 0x7) == 0) {\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n      }\n    }\n  }\n\n  /**\n   * Calculates extent of the `source` coordinates from all the triangles.\n   *\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\n   */\n  calculateSourceExtent() {\n    const extent = createEmpty();\n    this.triangles_.forEach(function (triangle, i, arr) {\n      const src = triangle.source;\n      extendCoordinate(extent, src[0]);\n      extendCoordinate(extent, src[1]);\n      extendCoordinate(extent, src[2]);\n    });\n    return extent;\n  }\n\n  /**\n   * @return {Array<Triangle>} Array of the calculated triangles.\n   */\n  getTriangles() {\n    return this.triangles_;\n  }\n}\nexport default Triangulation;"],
  "mappings": "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",
  "names": ["width", "height", "xPos", "yPos", "source"]
}
