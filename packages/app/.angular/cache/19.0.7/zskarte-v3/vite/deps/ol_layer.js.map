{
  "version": 3,
  "sources": ["../../../../../../../../node_modules/ol/webgl/RenderTarget.js", "../../../../../../../../node_modules/ol/render/webgl/constants.js", "../../../../../../../../node_modules/ol/worker/webgl.js", "../../../../../../../../node_modules/ol/renderer/webgl/worldUtil.js", "../../../../../../../../node_modules/ol/renderer/webgl/PointsLayer.js", "../../../../../../../../node_modules/ol/layer/Heatmap.js", "../../../../../../../../node_modules/ol/renderer/canvas/VectorImageLayer.js", "../../../../../../../../node_modules/ol/layer/VectorImage.js", "../../../../../../../../node_modules/ol/layer/WebGLPoints.js", "../../../../../../../../node_modules/ol/render/webgl/MixedGeometryBatch.js", "../../../../../../../../node_modules/ol/render/webgl/renderinstructions.js", "../../../../../../../../node_modules/ol/render/webgl/VectorStyleRenderer.js", "../../../../../../../../node_modules/ol/renderer/webgl/VectorLayer.js", "../../../../../../../../node_modules/ol/layer/WebGLVector.js"],
  "sourcesContent": ["/**\n * A wrapper class to simplify rendering to a texture instead of the final canvas\n * @module ol/webgl/RenderTarget\n */\nimport { equals } from '../array.js';\n\n// for pixel color reading\nconst tmpArray4 = new Uint8Array(4);\n\n/**\n * @classdesc\n * This class is a wrapper around the association of both a `WebGLTexture` and a `WebGLFramebuffer` instances,\n * simplifying initialization and binding for rendering.\n */\nclass WebGLRenderTarget {\n  /**\n   * @param {import(\"./Helper.js\").default} helper WebGL helper; mandatory.\n   * @param {Array<number>} [size] Expected size of the render target texture; note: this can be changed later on.\n   */\n  constructor(helper, size) {\n    /**\n     * @private\n     * @type {import(\"./Helper.js\").default}\n     */\n    this.helper_ = helper;\n    const gl = helper.getGL();\n\n    /**\n     * @private\n     * @type {WebGLTexture}\n     */\n    this.texture_ = gl.createTexture();\n\n    /**\n     * @private\n     * @type {WebGLFramebuffer}\n     */\n    this.framebuffer_ = gl.createFramebuffer();\n\n    /**\n     * @private\n     * @type {WebGLRenderbuffer}\n     */\n    this.depthbuffer_ = gl.createRenderbuffer();\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.size_ = size || [1, 1];\n\n    /**\n     * @type {Uint8Array}\n     * @private\n     */\n    this.data_ = new Uint8Array(0);\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.dataCacheDirty_ = true;\n    this.updateSize_();\n  }\n\n  /**\n   * Changes the size of the render target texture. Note: will do nothing if the size\n   * is already the same.\n   * @param {Array<number>} size Expected size of the render target texture\n   */\n  setSize(size) {\n    if (equals(size, this.size_)) {\n      return;\n    }\n    this.size_[0] = size[0];\n    this.size_[1] = size[1];\n    this.updateSize_();\n  }\n\n  /**\n   * Returns the size of the render target texture\n   * @return {Array<number>} Size of the render target texture\n   */\n  getSize() {\n    return this.size_;\n  }\n\n  /**\n   * This will cause following calls to `#readAll` or `#readPixel` to download the content of the\n   * render target into memory, which is an expensive operation.\n   * This content will be kept in cache but should be cleared after each new render.\n   */\n  clearCachedData() {\n    this.dataCacheDirty_ = true;\n  }\n\n  /**\n   * Returns the full content of the frame buffer as a series of r, g, b, a components\n   * in the 0-255 range (unsigned byte).\n   * @return {Uint8Array} Integer array of color values\n   */\n  readAll() {\n    if (this.dataCacheDirty_) {\n      const size = this.size_;\n      const gl = this.helper_.getGL();\n      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer_);\n      gl.readPixels(0, 0, size[0], size[1], gl.RGBA, gl.UNSIGNED_BYTE, this.data_);\n      this.dataCacheDirty_ = false;\n    }\n    return this.data_;\n  }\n\n  /**\n   * Reads one pixel of the frame buffer as an array of r, g, b, a components\n   * in the 0-255 range (unsigned byte).\n   * If x and/or y are outside of existing data, an array filled with 0 is returned.\n   * @param {number} x Pixel coordinate\n   * @param {number} y Pixel coordinate\n   * @return {Uint8Array} Integer array with one color value (4 components)\n   */\n  readPixel(x, y) {\n    if (x < 0 || y < 0 || x > this.size_[0] || y >= this.size_[1]) {\n      tmpArray4[0] = 0;\n      tmpArray4[1] = 0;\n      tmpArray4[2] = 0;\n      tmpArray4[3] = 0;\n      return tmpArray4;\n    }\n    this.readAll();\n    const index = Math.floor(x) + (this.size_[1] - Math.floor(y) - 1) * this.size_[0];\n    tmpArray4[0] = this.data_[index * 4];\n    tmpArray4[1] = this.data_[index * 4 + 1];\n    tmpArray4[2] = this.data_[index * 4 + 2];\n    tmpArray4[3] = this.data_[index * 4 + 3];\n    return tmpArray4;\n  }\n\n  /**\n   * @return {WebGLTexture} Texture to render to\n   */\n  getTexture() {\n    return this.texture_;\n  }\n\n  /**\n   * @return {WebGLFramebuffer} Frame buffer of the render target\n   */\n  getFramebuffer() {\n    return this.framebuffer_;\n  }\n\n  /**\n   * @return {WebGLRenderbuffer} Depth buffer of the render target\n   */\n  getDepthbuffer() {\n    return this.depthbuffer_;\n  }\n\n  /**\n   * @private\n   */\n  updateSize_() {\n    const size = this.size_;\n    const gl = this.helper_.getGL();\n    this.texture_ = this.helper_.createTexture(size, null, this.texture_);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer_);\n    gl.viewport(0, 0, size[0], size[1]);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture_, 0);\n    gl.bindRenderbuffer(gl.RENDERBUFFER, this.depthbuffer_);\n    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, size[0], size[1]);\n    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.depthbuffer_);\n    this.data_ = new Uint8Array(size[0] * size[1] * 4);\n  }\n}\nexport default WebGLRenderTarget;", "/**\n * @module ol/render/webgl/constants\n */\n\n/**\n * @enum {string}\n */\nexport const WebGLWorkerMessageType = {\n  GENERATE_POLYGON_BUFFERS: 'GENERATE_POLYGON_BUFFERS',\n  GENERATE_POINT_BUFFERS: 'GENERATE_POINT_BUFFERS',\n  GENERATE_LINE_STRING_BUFFERS: 'GENERATE_LINE_STRING_BUFFERS'\n};\n\n/**\n * @typedef {Object} WebGLWorkerGenerateBuffersMessage\n * This message will trigger the generation of a vertex and an index buffer based on the given render instructions.\n * When the buffers are generated, the worked will send a message of the same type to the main thread, with\n * the generated buffers in it.\n * Note that any addition properties present in the message *will* be sent back to the main thread.\n * @property {number} id Message id; will be used both in request and response as a means of identification\n * @property {WebGLWorkerMessageType} type Message type\n * @property {ArrayBuffer} renderInstructions render instructions raw binary buffer.\n * @property {number} [customAttributesSize] Amount of hit detection + custom attributes count in the render instructions.\n * @property {ArrayBuffer} [vertexBuffer] Vertices array raw binary buffer (sent by the worker).\n * @property {ArrayBuffer} [indexBuffer] Indices array raw binary buffer (sent by the worker).\n * @property {import(\"../../transform\").Transform} [renderInstructionsTransform] Transformation matrix used to project the instructions coordinates\n */", "export function create() {\n  const source = \"const t=\\\"GENERATE_POLYGON_BUFFERS\\\",e=\\\"GENERATE_POINT_BUFFERS\\\",n=\\\"GENERATE_LINE_STRING_BUFFERS\\\";function r(t,e){const n=e[0],r=e[1];return e[0]=t[0]*n+t[2]*r+t[4],e[1]=t[1]*n+t[3]*r+t[5],e}function x(t,e){const n=(r=e)[0]*r[3]-r[1]*r[2];var r;!function(t,e){if(!t)throw new Error(e)}(0!==n,\\\"Transformation matrix cannot be inverted\\\");const x=e[0],o=e[1],u=e[2],i=e[3],f=e[4],s=e[5];return t[0]=i/n,t[1]=-o/n,t[2]=-u/n,t[3]=x/n,t[4]=(u*s-i*f)/n,t[5]=-(x*s-o*f)/n,t}function o(t,e,n=2){const r=e&&e.length,x=r?e[0]*n:t.length;let o=u(t,0,x,n,!0);const i=[];if(!o||o.next===o.prev)return i;let s,l,c;if(r&&(o=function(t,e,n,r){const x=[];for(let n=0,o=e.length;n<o;n++){const i=u(t,e[n]*r,n<o-1?e[n+1]*r:t.length,r,!1);i===i.next&&(i.steiner=!0),x.push(g(i))}x.sort(y);for(let t=0;t<x.length;t++)n=h(x[t],n);return n}(t,e,o,n)),t.length>80*n){s=1/0,l=1/0;let e=-1/0,r=-1/0;for(let o=n;o<x;o+=n){const n=t[o],x=t[o+1];n<s&&(s=n),x<l&&(l=x),n>e&&(e=n),x>r&&(r=x)}c=Math.max(e-s,r-l),c=0!==c?32767/c:0}return f(o,i,n,s,l,c,0),i}function u(t,e,n,r,x){let o;if(x===function(t,e,n,r){let x=0;for(let o=e,u=n-r;o<n;o+=r)x+=(t[u]-t[o])*(t[o+1]+t[u+1]),u=o;return x}(t,e,n,r)>0)for(let x=e;x<n;x+=r)o=z(x/r|0,t[x],t[x+1],o);else for(let x=n-r;x>=e;x-=r)o=z(x/r|0,t[x],t[x+1],o);return o&&M(o,o.next)&&(F(o),o=o.next),o}function i(t,e){if(!t)return t;e||(e=t);let n,r=t;do{if(n=!1,r.steiner||!M(r,r.next)&&0!==d(r.prev,r,r.next))r=r.next;else{if(F(r),r=e=r.prev,r===r.next)break;n=!0}}while(n||r!==e);return e}function f(t,e,n,r,x,o,u){if(!t)return;!u&&o&&function(t,e,n,r){let x=t;do{0===x.z&&(x.z=v(x.x,x.y,e,n,r)),x.prevZ=x.prev,x.nextZ=x.next,x=x.next}while(x!==t);x.prevZ.nextZ=null,x.prevZ=null,function(t){let e,n=1;do{let r,x=t;t=null;let o=null;for(e=0;x;){e++;let u=x,i=0;for(let t=0;t<n&&(i++,u=u.nextZ,u);t++);let f=n;for(;i>0||f>0&&u;)0!==i&&(0===f||!u||x.z<=u.z)?(r=x,x=x.nextZ,i--):(r=u,u=u.nextZ,f--),o?o.nextZ=r:t=r,r.prevZ=o,o=r;x=u}o.nextZ=null,n*=2}while(e>1)}(x)}(t,r,x,o);let y=t;for(;t.prev!==t.next;){const h=t.prev,p=t.next;if(o?l(t,r,x,o):s(t))e.push(h.i,t.i,p.i),F(t),t=p.next,y=p.next;else if((t=p)===y){u?1===u?f(t=c(i(t),e),e,n,r,x,o,2):2===u&&a(t,e,n,r,x,o):f(i(t),e,n,r,x,o,1);break}}}function s(t){const e=t.prev,n=t,r=t.next;if(d(e,n,r)>=0)return!1;const x=e.x,o=n.x,u=r.x,i=e.y,f=n.y,s=r.y,l=x<o?x<u?x:u:o<u?o:u,c=i<f?i<s?i:s:f<s?f:s,a=x>o?x>u?x:u:o>u?o:u,y=i>f?i>s?i:s:f>s?f:s;let h=r.next;for(;h!==e;){if(h.x>=l&&h.x<=a&&h.y>=c&&h.y<=y&&b(x,i,o,f,u,s,h.x,h.y)&&d(h.prev,h,h.next)>=0)return!1;h=h.next}return!0}function l(t,e,n,r){const x=t.prev,o=t,u=t.next;if(d(x,o,u)>=0)return!1;const i=x.x,f=o.x,s=u.x,l=x.y,c=o.y,a=u.y,y=i<f?i<s?i:s:f<s?f:s,h=l<c?l<a?l:a:c<a?c:a,p=i>f?i>s?i:s:f>s?f:s,g=l>c?l>a?l:a:c>a?c:a,Z=v(y,h,e,n,r),M=v(p,g,e,n,r);let w=t.prevZ,m=t.nextZ;for(;w&&w.z>=Z&&m&&m.z<=M;){if(w.x>=y&&w.x<=p&&w.y>=h&&w.y<=g&&w!==x&&w!==u&&b(i,l,f,c,s,a,w.x,w.y)&&d(w.prev,w,w.next)>=0)return!1;if(w=w.prevZ,m.x>=y&&m.x<=p&&m.y>=h&&m.y<=g&&m!==x&&m!==u&&b(i,l,f,c,s,a,m.x,m.y)&&d(m.prev,m,m.next)>=0)return!1;m=m.nextZ}for(;w&&w.z>=Z;){if(w.x>=y&&w.x<=p&&w.y>=h&&w.y<=g&&w!==x&&w!==u&&b(i,l,f,c,s,a,w.x,w.y)&&d(w.prev,w,w.next)>=0)return!1;w=w.prevZ}for(;m&&m.z<=M;){if(m.x>=y&&m.x<=p&&m.y>=h&&m.y<=g&&m!==x&&m!==u&&b(i,l,f,c,s,a,m.x,m.y)&&d(m.prev,m,m.next)>=0)return!1;m=m.nextZ}return!0}function c(t,e){let n=t;do{const r=n.prev,x=n.next.next;!M(r,x)&&w(r,n,n.next,x)&&E(r,x)&&E(x,r)&&(e.push(r.i,n.i,x.i),F(n),F(n.next),n=t=x),n=n.next}while(n!==t);return i(n)}function a(t,e,n,r,x,o){let u=t;do{let t=u.next.next;for(;t!==u.prev;){if(u.i!==t.i&&Z(u,t)){let s=I(u,t);return u=i(u,u.next),s=i(s,s.next),f(u,e,n,r,x,o,0),void f(s,e,n,r,x,o,0)}t=t.next}u=u.next}while(u!==t)}function y(t,e){return t.x-e.x}function h(t,e){const n=function(t,e){let n=e;const r=t.x,x=t.y;let o,u=-1/0;do{if(x<=n.y&&x>=n.next.y&&n.next.y!==n.y){const t=n.x+(x-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(t<=r&&t>u&&(u=t,o=n.x<n.next.x?n:n.next,t===r))return o}n=n.next}while(n!==e);if(!o)return null;const i=o,f=o.x,s=o.y;let l=1/0;n=o;do{if(r>=n.x&&n.x>=f&&r!==n.x&&b(x<s?r:u,x,f,s,x<s?u:r,x,n.x,n.y)){const e=Math.abs(x-n.y)/(r-n.x);E(n,t)&&(e<l||e===l&&(n.x>o.x||n.x===o.x&&p(o,n)))&&(o=n,l=e)}n=n.next}while(n!==i);return o}(t,e);if(!n)return e;const r=I(n,t);return i(r,r.next),i(n,n.next)}function p(t,e){return d(t.prev,t,e.prev)<0&&d(e.next,t,t.next)<0}function v(t,e,n,r,x){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-n)*x|0)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-r)*x|0)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function g(t){let e=t,n=t;do{(e.x<n.x||e.x===n.x&&e.y<n.y)&&(n=e),e=e.next}while(e!==t);return n}function b(t,e,n,r,x,o,u,i){return(x-u)*(e-i)>=(t-u)*(o-i)&&(t-u)*(r-i)>=(n-u)*(e-i)&&(n-u)*(o-i)>=(x-u)*(r-i)}function Z(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){let n=t;do{if(n.i!==t.i&&n.next.i!==t.i&&n.i!==e.i&&n.next.i!==e.i&&w(n,n.next,t,e))return!0;n=n.next}while(n!==t);return!1}(t,e)&&(E(t,e)&&E(e,t)&&function(t,e){let n=t,r=!1;const x=(t.x+e.x)/2,o=(t.y+e.y)/2;do{n.y>o!=n.next.y>o&&n.next.y!==n.y&&x<(n.next.x-n.x)*(o-n.y)/(n.next.y-n.y)+n.x&&(r=!r),n=n.next}while(n!==t);return r}(t,e)&&(d(t.prev,t,e.prev)||d(t,e.prev,e))||M(t,e)&&d(t.prev,t,t.next)>0&&d(e.prev,e,e.next)>0)}function d(t,e,n){return(e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y)}function M(t,e){return t.x===e.x&&t.y===e.y}function w(t,e,n,r){const x=A(d(t,e,n)),o=A(d(t,e,r)),u=A(d(n,r,t)),i=A(d(n,r,e));return x!==o&&u!==i||(!(0!==x||!m(t,n,e))||(!(0!==o||!m(t,r,e))||(!(0!==u||!m(n,t,r))||!(0!==i||!m(n,e,r)))))}function m(t,e,n){return e.x<=Math.max(t.x,n.x)&&e.x>=Math.min(t.x,n.x)&&e.y<=Math.max(t.y,n.y)&&e.y>=Math.min(t.y,n.y)}function A(t){return t>0?1:t<0?-1:0}function E(t,e){return d(t.prev,t,t.next)<0?d(t,e,t.next)>=0&&d(t,t.prev,e)>=0:d(t,e,t.prev)<0||d(t,t.next,e)<0}function I(t,e){const n=P(t.i,t.x,t.y),r=P(e.i,e.x,e.y),x=t.next,o=e.prev;return t.next=e,e.prev=t,n.next=x,x.prev=n,r.next=n,n.prev=r,o.next=r,r.prev=o,r}function z(t,e,n,r){const x=P(t,e,n);return r?(x.next=r.next,x.prev=r,r.next.prev=x,r.next=x):(x.prev=x,x.next=x),x}function F(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function P(t,e,n){return{i:t,x:e,y:n,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}new Array(6);const B=[],N={vertexPosition:0,indexPosition:0};function R(t,e,n,r,x){t[e+0]=n,t[e+1]=r,t[e+2]=x}function S(t,e,n,r,x,o){const u=3+x,i=t[e+0],f=t[e+1],s=B;s.length=x;for(let n=0;n<s.length;n++)s[n]=t[e+2+n];let l=o?o.vertexPosition:0,c=o?o.indexPosition:0;const a=l/u;return R(n,l,i,f,0),s.length&&n.set(s,l+3),l+=u,R(n,l,i,f,1),s.length&&n.set(s,l+3),l+=u,R(n,l,i,f,2),s.length&&n.set(s,l+3),l+=u,R(n,l,i,f,3),s.length&&n.set(s,l+3),l+=u,r[c++]=a,r[c++]=a+1,r[c++]=a+3,r[c++]=a+1,r[c++]=a+2,r[c++]=a+3,N.vertexPosition=l,N.indexPosition=c,N}function T(t,e,n,x,o,u,i,f,s,l,c){const a=10+f.length,y=u.length/a,h=[t[e+0],t[e+1]],p=[t[n],t[n+1]],v=t[e+2],g=t[n+2],b=r(s,[...h]),Z=r(s,[...p]);function d(t,e,n){const r=Math.sqrt((e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1])),x=[(e[0]-t[0])/r,(e[1]-t[1])/r],o=[-x[1],x[0]],u=Math.sqrt((n[0]-t[0])*(n[0]-t[0])+(n[1]-t[1])*(n[1]-t[1])),i=[(n[0]-t[0])/u,(n[1]-t[1])/u],f=0===r||0===u?0:Math.acos((s=i[0]*x[0]+i[1]*x[1],l=-1,c=1,Math.min(Math.max(s,l),c)));var s,l,c;return i[0]*o[0]+i[1]*o[1]>0?f:2*Math.PI-f}let M=-1,w=-1,m=c;const A=null!==o;if(null!==x){M=d(b,Z,r(s,[...[t[x],t[x+1]]])),Math.cos(M)<=.985&&(m+=Math.tan((M-Math.PI)/2))}if(A){w=d(Z,b,r(s,[...[t[o],t[o+1]]])),Math.cos(w)<=.985&&(m+=Math.tan((Math.PI-w)/2))}function E(t,e){return 0===e?1e4*t:Math.sign(e)*(1e4*t+Math.abs(e))}return u.push(h[0],h[1],v,p[0],p[1],g,M,w,l,E(0,c)),u.push(...f),u.push(h[0],h[1],v,p[0],p[1],g,M,w,l,E(1,c)),u.push(...f),u.push(h[0],h[1],v,p[0],p[1],g,M,w,l,E(2,c)),u.push(...f),u.push(h[0],h[1],v,p[0],p[1],g,M,w,l,E(3,c)),u.push(...f),i.push(y,y+1,y+2,y+1,y+3,y+2),{length:l+Math.sqrt((Z[0]-b[0])*(Z[0]-b[0])+(Z[1]-b[1])*(Z[1]-b[1])),angle:m}}function _(t,e,n,r,x){const u=2+x;let i=e;const f=t.slice(i,i+x);i+=x;const s=t[i++];let l=0;const c=new Array(s-1);for(let e=0;e<s;e++)l+=t[i++],e<s-1&&(c[e]=l);const a=t.slice(i,i+2*l),y=o(a,c,2);for(let t=0;t<y.length;t++)r.push(y[t]+n.length/u);for(let t=0;t<a.length;t+=2)n.push(a[t],a[t+1],...f);return i+2*l}const O=self;O.onmessage=r=>{const o=r.data;switch(o.type){case e:{const t=3,e=2,n=o.customAttributesSize,r=e+n,x=new Float32Array(o.renderInstructions),u=x.length/r,i=4*u*(n+t),f=new Uint32Array(6*u),s=new Float32Array(i);let l;for(let t=0;t<x.length;t+=r)l=S(x,t,s,f,n,l);const c=Object.assign({vertexBuffer:s.buffer,indexBuffer:f.buffer,renderInstructions:x.buffer},o);O.postMessage(c,[s.buffer,f.buffer,x.buffer]);break}case n:{const t=[],e=[],n=o.customAttributesSize,r=3,u=new Float32Array(o.renderInstructions);let i=0;const f=[1,0,0,1,0,0];let s,l;for(x(f,o.renderInstructionsTransform);i<u.length;){l=Array.from(u.slice(i,i+n)),i+=n,s=u[i++];const x=i,o=i+(s-1)*r,c=u[x]===u[o]&&u[x+1]===u[o+1];let a=0,y=0;for(let n=0;n<s-1;n++){let h=null;n>0?h=i+(n-1)*r:c&&(h=o-r);let p=null;n<s-2?p=i+(n+2)*r:c&&(p=x+r);const v=T(u,i+n*r,i+(n+1)*r,h,p,t,e,l,f,a,y);a=v.length,y=v.angle}i+=s*r}const c=Uint32Array.from(e),a=Float32Array.from(t),y=Object.assign({vertexBuffer:a.buffer,indexBuffer:c.buffer,renderInstructions:u.buffer},o);O.postMessage(y,[a.buffer,c.buffer,u.buffer]);break}case t:{const t=[],e=[],n=o.customAttributesSize,r=new Float32Array(o.renderInstructions);let x=0;for(;x<r.length;)x=_(r,x,t,e,n);const u=Uint32Array.from(e),i=Float32Array.from(t),f=Object.assign({vertexBuffer:i.buffer,indexBuffer:u.buffer,renderInstructions:r.buffer},o);O.postMessage(f,[i.buffer,u.buffer,r.buffer]);break}}};\";\n  return new Worker(typeof Blob === 'undefined' ? 'data:application/javascript;base64,' + Buffer.from(source, 'binary').toString('base64') : URL.createObjectURL(new Blob([source], {\n    type: 'application/javascript'\n  })));\n}", "import { getWidth } from '../../extent.js';\n\n/**\n * Compute world params\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {any} layer The layer\n * @return {Array<number>} The world start, end and width.\n */\nexport function getWorldParameters(frameState, layer) {\n  const projection = frameState.viewState.projection;\n  const vectorSource = layer.getSource();\n  const multiWorld = vectorSource.getWrapX() && projection.canWrapX();\n  const projectionExtent = projection.getExtent();\n  const extent = frameState.extent;\n  const worldWidth = multiWorld ? getWidth(projectionExtent) : null;\n  const endWorld = multiWorld ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1 : 1;\n  const startWorld = multiWorld ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth) : 0;\n  return [startWorld, endWorld, worldWidth];\n}", "/**\n * @module ol/renderer/webgl/PointsLayer\n */\nimport BaseVector from '../../layer/BaseVector.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport { ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER } from '../../webgl.js';\nimport { AttributeType, DefaultUniform } from '../../webgl/Helper.js';\nimport { WebGLWorkerMessageType } from '../../render/webgl/constants.js';\nimport { apply as applyTransform, create as createTransform, makeInverse as makeInverseTransform, multiply as multiplyTransform, translate as translateTransform } from '../../transform.js';\nimport { assert } from '../../asserts.js';\nimport { buffer, createEmpty, equals } from '../../extent.js';\nimport { colorDecodeId, colorEncodeId } from '../../render/webgl/utils.js';\nimport { create as createWebGLWorker } from '../../worker/webgl.js';\nimport { fromUserCoordinate, getUserProjection } from '../../proj.js';\nimport { getUid } from '../../util.js';\nimport { getWorldParameters } from './worldUtil.js';\nimport { listen, unlistenByKey } from '../../events.js';\n\n/**\n * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {string} name Attribute name.\n * @property {function(import(\"../../Feature\").default, Object<string, *>):number} callback This callback computes the numerical value of the\n * attribute for a given feature (properties are available as 2nd arg for quicker access).\n */\n\n/**\n * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize\n * rebuildBuffers by accessing these objects quicker.\n * @property {import(\"../../Feature\").default} feature Feature\n * @property {Object<string, *>} properties Feature properties\n * @property {import(\"../../geom\").Geometry} geometry Feature geometry\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then\n * passed to the GPU. The `name` property of each attribute will serve as its identifier:\n *  * In the vertex shader as an `attribute` by prefixing it with `a_`\n *  * In the fragment shader as a `varying` by prefixing it with `v_`\n * Please note that these can only be numerical values.\n * @property {string} vertexShader Vertex shader source, mandatory.\n * @property {string} fragmentShader Fragment shader source, mandatory.\n * @property {boolean} [hitDetectionEnabled] Whether shader is hit detection aware.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * Please note that `u_texture` is reserved for the main texture slot and `u_opacity` is reserved for the layer opacity.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * WebGL vector renderer optimized for points.\n * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU\n * every time the vector source changes.\n *\n * You need to provide vertex and fragment shaders for rendering. This can be done using\n * {@link module:ol/webgl/ShaderBuilder~ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute\n * containing the screen-space projected center of the quad, as well as a `a_index` attribute\n * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).\n *\n * To include variable attributes in the shaders, you need to declare them using the `attributes` property of\n * the options object like so:\n * ```js\n * new WebGLPointsLayerRenderer(layer, {\n *   attributes: [\n *     {\n *       name: 'size',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *     {\n *       name: 'weight',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *   ],\n *   vertexShader:\n *     // shader using attribute a_weight and a_size\n *   fragmentShader:\n *     // shader using varying v_weight and v_size\n * ```\n *\n * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`\n * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain\n * the final color that will have to be output for hit detection to work.\n *\n * The following uniform is used for the main texture: `u_texture`.\n * The following uniform is used for the layer opacity: `u_opacity`.\n *\n * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Points are rendered as quads with the following structure:\n *\n * ```\n *   (u0, v1)      (u1, v1)\n *  [3]----------[2]\n *   |`           |\n *   |  `         |\n *   |    `       |\n *   |      `     |\n *   |        `   |\n *   |          ` |\n *  [0]----------[1]\n *   (u0, v0)      (u1, v0)\n *  ```\n *\n * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n *\n * @api\n */\nclass WebGLPointsLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n   * @param {Options} options Options.\n   */\n  constructor(layer, options) {\n    const uniforms = options.uniforms || {};\n    const projectionMatrixTransform = createTransform();\n    uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;\n    super(layer, {\n      uniforms: uniforms,\n      postProcesses: options.postProcesses\n    });\n\n    /**\n     * @private\n     */\n    this.sourceRevision_ = -1;\n\n    /**\n     * @private\n     */\n    this.verticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n    /**\n     * @private\n     */\n    this.indicesBuffer_ = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, DYNAMIC_DRAW);\n\n    /**\n     * @private\n     */\n    this.vertexShader_ = options.vertexShader;\n\n    /**\n     * @private\n     */\n    this.fragmentShader_ = options.fragmentShader;\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.program_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hitDetectionEnabled_ = options.hitDetectionEnabled ?? true;\n    const customAttributes = options.attributes ? options.attributes.map(function (attribute) {\n      return {\n        name: 'a_' + attribute.name,\n        size: 1,\n        type: AttributeType.FLOAT\n      };\n    }) : [];\n\n    /**\n     * A list of attributes used by the renderer. By default only the position and\n     * index of the vertex (0 to 3) are required.\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     */\n    this.attributes = [{\n      name: 'a_position',\n      size: 2,\n      type: AttributeType.FLOAT\n    }, {\n      name: 'a_index',\n      size: 1,\n      type: AttributeType.FLOAT\n    }];\n    if (this.hitDetectionEnabled_) {\n      this.attributes.push({\n        name: 'a_hitColor',\n        size: 4,\n        type: AttributeType.FLOAT\n      });\n      this.attributes.push({\n        name: 'a_featureUid',\n        size: 1,\n        type: AttributeType.FLOAT\n      });\n    }\n    this.attributes.push(...customAttributes);\n    this.customAttributes = options.attributes ? options.attributes : [];\n\n    /**\n     * @private\n     */\n    this.previousExtent_ = createEmpty();\n\n    /**\n     * This transform is updated on every frame and is the composition of:\n     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n     * - current world->screen transform\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentTransform_ = projectionMatrixTransform;\n\n    /**\n     * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.renderTransform_ = createTransform();\n\n    /**\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.invertRenderTransform_ = createTransform();\n\n    /**\n     * @type {Float32Array}\n     * @private\n     */\n    this.renderInstructions_ = new Float32Array(0);\n\n    /**\n     * @type {WebGLRenderTarget}\n     * @private\n     */\n    this.hitRenderTarget_;\n\n    /**\n     * Keep track of latest message sent to worker\n     * @type {number}\n     * @private\n     */\n    this.lastSentId = 0;\n\n    /**\n     * @private\n     */\n    this.worker_ = createWebGLWorker();\n    this.worker_.addEventListener('message',\n    /**\n     * @param {*} event Event.\n     */\n    event => {\n      const received = event.data;\n      if (received.type === WebGLWorkerMessageType.GENERATE_POINT_BUFFERS) {\n        const projectionTransform = received.projectionTransform;\n        this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n        this.helper.flushBufferData(this.verticesBuffer_);\n        this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);\n        this.helper.flushBufferData(this.indicesBuffer_);\n        this.renderTransform_ = projectionTransform;\n        makeInverseTransform(this.invertRenderTransform_, this.renderTransform_);\n        this.renderInstructions_ = new Float32Array(event.data.renderInstructions);\n        if (received.id === this.lastSentId) {\n          this.ready = true;\n        }\n        this.getLayer().changed();\n      }\n    });\n\n    /**\n     * This object will be updated when the source changes. Key is uid.\n     * @type {Object<string, FeatureCacheItem>}\n     * @private\n     */\n    this.featureCache_ = {};\n\n    /**\n     * Amount of features in the cache.\n     * @type {number}\n     * @private\n     */\n    this.featureCount_ = 0;\n    const source = this.getLayer().getSource();\n    /**\n     * @private\n     */\n    this.sourceListenKeys_ = [listen(source, VectorEventType.ADDFEATURE, this.handleSourceFeatureAdded_, this), listen(source, VectorEventType.CHANGEFEATURE, this.handleSourceFeatureChanged_, this), listen(source, VectorEventType.REMOVEFEATURE, this.handleSourceFeatureDelete_, this), listen(source, VectorEventType.CLEAR, this.handleSourceFeatureClear_, this)];\n    source.forEachFeature(feature => {\n      this.featureCache_[getUid(feature)] = {\n        feature: feature,\n        properties: feature.getProperties(),\n        geometry: feature.getGeometry()\n      };\n      this.featureCount_++;\n    });\n  }\n\n  /**\n   * @override\n   */\n  afterHelperCreated() {\n    this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);\n    if (this.hitDetectionEnabled_) {\n      this.hitRenderTarget_ = new WebGLRenderTarget(this.helper);\n    }\n\n    // upload buffers again if any\n    if (this.verticesBuffer_.getArray()) {\n      this.helper.flushBufferData(this.verticesBuffer_);\n    }\n    if (this.indicesBuffer_.getArray()) {\n      this.helper.flushBufferData(this.indicesBuffer_);\n    }\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureAdded_(event) {\n    const feature = event.feature;\n    this.featureCache_[getUid(feature)] = {\n      feature: feature,\n      properties: feature.getProperties(),\n      geometry: feature.getGeometry()\n    };\n    this.featureCount_++;\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureChanged_(event) {\n    const feature = event.feature;\n    this.featureCache_[getUid(feature)] = {\n      feature: feature,\n      properties: feature.getProperties(),\n      geometry: feature.getGeometry()\n    };\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureDelete_(event) {\n    const feature = event.feature;\n    delete this.featureCache_[getUid(feature)];\n    this.featureCount_--;\n  }\n\n  /**\n   * @private\n   */\n  handleSourceFeatureClear_() {\n    this.featureCache_ = {};\n    this.featureCount_ = 0;\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState) {\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n    const [startWorld, endWorld, worldWidth] = getWorldParameters(frameState, this.getLayer());\n\n    // draw the normal canvas\n    this.renderWorlds(frameState, false, startWorld, endWorld, worldWidth);\n    this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);\n    if (this.hitDetectionEnabled_) {\n      // draw the hit buffer\n      this.renderWorlds(frameState, true, startWorld, endWorld, worldWidth);\n      this.hitRenderTarget_.clearCachedData();\n    }\n    this.postRender(gl, frameState);\n    const canvas = this.helper.getCanvas();\n    return canvas;\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrameInternal(frameState) {\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    const viewState = frameState.viewState;\n    const viewNotMoving = !frameState.viewHints[ViewHint.ANIMATING] && !frameState.viewHints[ViewHint.INTERACTING];\n    const extentChanged = !equals(this.previousExtent_, frameState.extent);\n    const sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n    if (sourceChanged) {\n      this.sourceRevision_ = vectorSource.getRevision();\n    }\n    if (viewNotMoving && (extentChanged || sourceChanged)) {\n      const projection = viewState.projection;\n      const resolution = viewState.resolution;\n      const renderBuffer = layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n      const extent = buffer(frameState.extent, renderBuffer * resolution);\n      vectorSource.loadFeatures(extent, resolution, projection);\n      this.rebuildBuffers_(frameState);\n      this.previousExtent_ = frameState.extent.slice();\n    }\n    this.helper.useProgram(this.program_, frameState);\n    this.helper.prepareDraw(frameState);\n\n    // write new data\n    this.helper.bindBuffer(this.verticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n    this.helper.enableAttributes(this.attributes);\n    return true;\n  }\n\n  /**\n   * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @private\n   */\n  rebuildBuffers_(frameState) {\n    // saves the projection transform for the current frame state\n    const projectionTransform = createTransform();\n    this.helper.makeProjectionTransform(frameState, projectionTransform);\n    const userProjection = getUserProjection();\n    const baseInstructionLength = this.hitDetectionEnabled_ ? 7 : 2; // see below\n    const singleInstructionLength = baseInstructionLength + this.customAttributes.length;\n    const totalSize = singleInstructionLength * this.featureCount_;\n    if (!this.renderInstructions_ || this.renderInstructions_.length !== totalSize) {\n      this.renderInstructions_ = new Float32Array(totalSize);\n    }\n\n    // loop on features to fill the buffer\n    let featureCache, geometry;\n    const tmpCoords = [];\n    const tmpColor = [];\n    let idx = -1;\n    for (const featureUid in this.featureCache_) {\n      featureCache = this.featureCache_[featureUid];\n      geometry = /** @type {import(\"../../geom\").Point} */\n      featureCache.geometry;\n      if (!geometry || geometry.getType() !== 'Point') {\n        continue;\n      }\n      if (userProjection) {\n        const userCoords = fromUserCoordinate(geometry.getFlatCoordinates(), frameState.viewState.projection);\n        tmpCoords[0] = userCoords[0];\n        tmpCoords[1] = userCoords[1];\n      } else {\n        tmpCoords[0] = geometry.getFlatCoordinates()[0];\n        tmpCoords[1] = geometry.getFlatCoordinates()[1];\n      }\n      applyTransform(projectionTransform, tmpCoords);\n      this.renderInstructions_[++idx] = tmpCoords[0];\n      this.renderInstructions_[++idx] = tmpCoords[1];\n\n      // for hit detection, the feature uid is saved in the opacity value\n      // and the index of the opacity value is encoded in the color values\n      if (this.hitDetectionEnabled_) {\n        const hitColor = colorEncodeId(idx + 5, tmpColor);\n        this.renderInstructions_[++idx] = hitColor[0];\n        this.renderInstructions_[++idx] = hitColor[1];\n        this.renderInstructions_[++idx] = hitColor[2];\n        this.renderInstructions_[++idx] = hitColor[3];\n        this.renderInstructions_[++idx] = Number(featureUid);\n      }\n\n      // pushing custom attributes\n      for (let j = 0; j < this.customAttributes.length; j++) {\n        const value = this.customAttributes[j].callback(featureCache.feature, featureCache.properties);\n        this.renderInstructions_[++idx] = value;\n      }\n    }\n\n    /** @type {import('../../render/webgl/constants.js').WebGLWorkerGenerateBuffersMessage} */\n    const message = {\n      id: ++this.lastSentId,\n      type: WebGLWorkerMessageType.GENERATE_POINT_BUFFERS,\n      renderInstructions: this.renderInstructions_.buffer,\n      customAttributesSize: singleInstructionLength - 2\n    };\n    // additional properties will be sent back as-is by the worker\n    message['projectionTransform'] = projectionTransform;\n    this.ready = false;\n    this.worker_.postMessage(message, [this.renderInstructions_.buffer]);\n    this.renderInstructions_ = null;\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   * @override\n   */\n  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {\n    assert(this.hitDetectionEnabled_, '`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has been disabled using the `disableHitDetection: true` option.');\n    if (!this.renderInstructions_ || !this.hitDetectionEnabled_) {\n      return undefined;\n    }\n    const pixel = applyTransform(frameState.coordinateToPixelTransform, coordinate.slice());\n    const data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n    const color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n    const index = colorDecodeId(color);\n    const opacity = this.renderInstructions_[index];\n    const uid = Math.floor(opacity).toString();\n    const source = this.getLayer().getSource();\n    const feature = source.getFeatureByUid(uid);\n    if (feature) {\n      return callback(feature, this.getLayer(), null);\n    }\n    return undefined;\n  }\n\n  /**\n   * Render the world, either to the main framebuffer or to the hit framebuffer\n   * @param {import(\"../../Map.js\").FrameState} frameState current frame state\n   * @param {boolean} forHitDetection whether the rendering is for hit detection\n   * @param {number} startWorld the world to render in the first iteration\n   * @param {number} endWorld the last world to render\n   * @param {number} worldWidth the width of the worlds being rendered\n   */\n  renderWorlds(frameState, forHitDetection, startWorld, endWorld, worldWidth) {\n    let world = startWorld;\n    this.helper.useProgram(this.program_, frameState);\n    if (forHitDetection) {\n      this.hitRenderTarget_.setSize([Math.floor(frameState.size[0] / 2), Math.floor(frameState.size[1] / 2)]);\n      this.helper.prepareDrawToRenderTarget(frameState, this.hitRenderTarget_, true);\n    }\n    this.helper.bindBuffer(this.verticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n    this.helper.enableAttributes(this.attributes);\n    do {\n      this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n      translateTransform(this.currentTransform_, world * worldWidth, 0);\n      multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n      this.helper.applyUniforms(frameState);\n      this.helper.applyHitDetectionUniform(forHitDetection);\n      const renderCount = this.indicesBuffer_.getSize();\n      this.helper.drawElements(0, renderCount);\n    } while (++world < endWorld);\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    this.worker_.terminate();\n    this.sourceListenKeys_.forEach(function (key) {\n      unlistenByKey(key);\n    });\n    this.sourceListenKeys_ = null;\n    super.disposeInternal();\n  }\n  renderDeclutter() {}\n}\nexport default WebGLPointsLayerRenderer;", "/**\n * @module ol/layer/Heatmap\n */\nimport BaseVector from './BaseVector.js';\nimport WebGLPointsLayerRenderer from '../renderer/webgl/PointsLayer.js';\nimport { ShaderBuilder } from '../webgl/ShaderBuilder.js';\nimport { clamp } from '../math.js';\nimport { createCanvasContext2D } from '../dom.js';\n\n/**\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n * @template {import(\"../source/Vector.js\").default<FeatureType>} [VectorSourceType=import(\"../source/Vector.js\").default<FeatureType>]\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {Array<string>} [gradient=['#00f', '#0ff', '#0f0', '#ff0', '#f00']] The color gradient\n * of the heatmap, specified as an array of CSS color strings.\n * @property {number} [radius=8] Radius size in pixels.\n * @property {number} [blur=15] Blur size in pixels.\n * @property {string|function(import(\"../Feature.js\").default):number} [weight='weight'] The feature\n * attribute to use for the weight or a function that returns a weight from a feature. Weight values\n * should range from 0 to 1 (and values outside will be clamped to that range).\n * @property {VectorSourceType} [source] Point source.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @enum {string}\n * @private\n */\nconst Property = {\n  BLUR: 'blur',\n  GRADIENT: 'gradient',\n  RADIUS: 'radius'\n};\n\n/**\n * @const\n * @type {Array<string>}\n */\nconst DEFAULT_GRADIENT = ['#00f', '#0ff', '#0f0', '#ff0', '#f00'];\n\n/**\n * @classdesc\n * Layer for rendering vector data as a heatmap.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @fires import(\"../render/Event.js\").RenderEvent#prerender\n * @fires import(\"../render/Event.js\").RenderEvent#postrender\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n * @template {import(\"../source/Vector.js\").default<FeatureType>} [VectorSourceType=import(\"../source/Vector.js\").default<FeatureType>]\n * @extends {BaseVector<FeatureType, VectorSourceType, WebGLPointsLayerRenderer>}\n * @api\n */\nclass Heatmap extends BaseVector {\n  /**\n   * @param {Options<FeatureType, VectorSourceType>} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n    const baseOptions = Object.assign({}, options);\n    delete baseOptions.gradient;\n    delete baseOptions.radius;\n    delete baseOptions.blur;\n    delete baseOptions.weight;\n    super(baseOptions);\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.gradient_ = null;\n    this.addChangeListener(Property.GRADIENT, this.handleGradientChanged_);\n    this.setGradient(options.gradient ? options.gradient : DEFAULT_GRADIENT);\n    this.setBlur(options.blur !== undefined ? options.blur : 15);\n    this.setRadius(options.radius !== undefined ? options.radius : 8);\n    const weight = options.weight ? options.weight : 'weight';\n\n    /**\n     * @private\n     */\n    this.weightFunction_ = typeof weight === 'string' ?\n    /**\n     * @param {import('../Feature.js').default} feature Feature\n     * @return {any} weight\n     */\n    feature => feature.get(weight) : weight;\n\n    // For performance reasons, don't sort the features before rendering.\n    // The render order is not relevant for a heatmap representation.\n    this.setRenderOrder(null);\n  }\n\n  /**\n   * Return the blur size in pixels.\n   * @return {number} Blur size in pixels.\n   * @api\n   * @observable\n   */\n  getBlur() {\n    return /** @type {number} */this.get(Property.BLUR);\n  }\n\n  /**\n   * Return the gradient colors as array of strings.\n   * @return {Array<string>} Colors.\n   * @api\n   * @observable\n   */\n  getGradient() {\n    return /** @type {Array<string>} */this.get(Property.GRADIENT);\n  }\n\n  /**\n   * Return the size of the radius in pixels.\n   * @return {number} Radius size in pixel.\n   * @api\n   * @observable\n   */\n  getRadius() {\n    return /** @type {number} */this.get(Property.RADIUS);\n  }\n\n  /**\n   * @private\n   */\n  handleGradientChanged_() {\n    this.gradient_ = createGradient(this.getGradient());\n  }\n\n  /**\n   * Set the blur size in pixels.\n   * @param {number} blur Blur size in pixels.\n   * @api\n   * @observable\n   */\n  setBlur(blur) {\n    this.set(Property.BLUR, blur);\n  }\n\n  /**\n   * Set the gradient colors as array of strings.\n   * @param {Array<string>} colors Gradient.\n   * @api\n   * @observable\n   */\n  setGradient(colors) {\n    this.set(Property.GRADIENT, colors);\n  }\n\n  /**\n   * Set the size of the radius in pixels.\n   * @param {number} radius Radius size in pixel.\n   * @api\n   * @observable\n   */\n  setRadius(radius) {\n    this.set(Property.RADIUS, radius);\n  }\n\n  /**\n   * @override\n   */\n  createRenderer() {\n    const builder = new ShaderBuilder().addAttribute('float a_weight').addVarying('v_weight', 'float', 'a_weight').addUniform('float u_size').addUniform('float u_blurSlope').setSymbolSizeExpression('vec2(u_size)').setSymbolColorExpression('vec4(smoothstep(0., 1., (1. - length(coordsPx * 2. / v_quadSizePx)) * u_blurSlope) * v_weight)');\n    return new WebGLPointsLayerRenderer(this, {\n      className: this.getClassName(),\n      attributes: [{\n        name: 'weight',\n        callback: feature => {\n          const weight = this.weightFunction_(feature);\n          return weight !== undefined ? clamp(weight, 0, 1) : 1;\n        }\n      }],\n      uniforms: {\n        u_size: () => {\n          return (this.get(Property.RADIUS) + this.get(Property.BLUR)) * 2;\n        },\n        u_blurSlope: () => {\n          return this.get(Property.RADIUS) / Math.max(1, this.get(Property.BLUR));\n        }\n      },\n      hitDetectionEnabled: true,\n      vertexShader: builder.getSymbolVertexShader(),\n      fragmentShader: builder.getSymbolFragmentShader(),\n      postProcesses: [{\n        fragmentShader: `\n            precision mediump float;\n\n            uniform sampler2D u_image;\n            uniform sampler2D u_gradientTexture;\n            uniform float u_opacity;\n\n            varying vec2 v_texCoord;\n\n            void main() {\n              vec4 color = texture2D(u_image, v_texCoord);\n              gl_FragColor.a = color.a * u_opacity;\n              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;\n              gl_FragColor.rgb *= gl_FragColor.a;\n            }`,\n        uniforms: {\n          u_gradientTexture: () => this.gradient_,\n          u_opacity: () => this.getOpacity()\n        }\n      }]\n    });\n  }\n\n  /**\n   * @override\n   */\n  renderDeclutter() {}\n}\n\n/**\n * @param {Array<string>} colors A list of colored.\n * @return {HTMLCanvasElement} canvas with gradient texture.\n */\nfunction createGradient(colors) {\n  const width = 1;\n  const height = 256;\n  const context = createCanvasContext2D(width, height);\n  const gradient = context.createLinearGradient(0, 0, width, height);\n  const step = 1 / (colors.length - 1);\n  for (let i = 0, ii = colors.length; i < ii; ++i) {\n    gradient.addColorStop(i * step, colors[i]);\n  }\n  context.fillStyle = gradient;\n  context.fillRect(0, 0, width, height);\n  return context.canvas;\n}\nexport default Heatmap;", "/**\n * @module ol/renderer/canvas/VectorImageLayer\n */\nimport CanvasImageLayerRenderer from './ImageLayer.js';\nimport CanvasVectorLayerRenderer from './VectorLayer.js';\nimport EventType from '../../events/EventType.js';\nimport ImageCanvas from '../../ImageCanvas.js';\nimport ImageState from '../../ImageState.js';\nimport RBush from 'rbush';\nimport ViewHint from '../../ViewHint.js';\nimport { apply, compose, create } from '../../transform.js';\nimport { fromResolutionLike } from '../../resolution.js';\nimport { getHeight, getWidth, isEmpty, scaleFromCenter } from '../../extent.js';\n\n/**\n * @classdesc\n * Canvas renderer for image layers.\n * @api\n */\nclass CanvasVectorImageLayerRenderer extends CanvasImageLayerRenderer {\n  /**\n   * @param {import(\"../../layer/VectorImage.js\").default} layer Vector image layer.\n   */\n  constructor(layer) {\n    super(layer);\n\n    /**\n     * @private\n     * @type {import(\"./VectorLayer.js\").default}\n     */\n    this.vectorRenderer_ = new CanvasVectorLayerRenderer(layer);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.layerImageRatio_ = layer.getImageRatio();\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.coordinateToVectorPixelTransform_ = create();\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.renderedPixelToCoordinateTransform_ = null;\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    this.vectorRenderer_.dispose();\n    super.disposeInternal();\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature\").default>>} Promise that resolves with an array of features.\n   * @override\n   */\n  getFeatures(pixel) {\n    if (!this.vectorRenderer_) {\n      return Promise.resolve([]);\n    }\n    const vectorPixel = apply(this.coordinateToVectorPixelTransform_, apply(this.renderedPixelToCoordinateTransform_, pixel.slice()));\n    return this.vectorRenderer_.getFeatures(vectorPixel);\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @override\n   */\n  handleFontsChanged() {\n    this.vectorRenderer_.handleFontsChanged();\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewResolution = viewState.resolution;\n    const hints = frameState.viewHints;\n    const vectorRenderer = this.vectorRenderer_;\n    let renderedExtent = frameState.extent;\n    if (this.layerImageRatio_ !== 1) {\n      renderedExtent = renderedExtent.slice(0);\n      scaleFromCenter(renderedExtent, this.layerImageRatio_);\n    }\n    const width = getWidth(renderedExtent) / viewResolution;\n    const height = getHeight(renderedExtent) / viewResolution;\n    if (!hints[ViewHint.ANIMATING] && !hints[ViewHint.INTERACTING] && !isEmpty(renderedExtent)) {\n      vectorRenderer.useContainer(null, null);\n      const context = vectorRenderer.context;\n      const layerState = frameState.layerStatesArray[frameState.layerIndex];\n      const imageLayerState = Object.assign({}, layerState, {\n        opacity: 1\n      });\n      const imageFrameState = /** @type {import(\"../../Map.js\").FrameState} */\n      Object.assign({}, frameState, {\n        extent: renderedExtent,\n        size: [width, height],\n        viewState: (/** @type {import(\"../../View.js\").State} */\n        Object.assign({}, frameState.viewState, {\n          rotation: 0\n        })),\n        layerStatesArray: [imageLayerState],\n        layerIndex: 0,\n        declutter: null\n      });\n      const declutter = this.getLayer().getDeclutter();\n      if (declutter) {\n        imageFrameState.declutter = {\n          [declutter]: new RBush(9)\n        };\n      }\n      let emptyImage = true;\n      const image = new ImageCanvas(renderedExtent, viewResolution, pixelRatio, context.canvas, function (callback) {\n        if (vectorRenderer.prepareFrame(imageFrameState) && vectorRenderer.replayGroupChanged) {\n          vectorRenderer.clipping = false;\n          if (vectorRenderer.renderFrame(imageFrameState, null)) {\n            vectorRenderer.renderDeclutter(imageFrameState);\n            vectorRenderer.renderDeferred(imageFrameState);\n            emptyImage = false;\n          }\n          callback();\n        }\n      });\n      image.addEventListener(EventType.CHANGE, () => {\n        if (image.getState() !== ImageState.LOADED) {\n          return;\n        }\n        this.image = emptyImage ? null : image;\n        const imagePixelRatio = image.getPixelRatio();\n        const renderedResolution = fromResolutionLike(image.getResolution()) * pixelRatio / imagePixelRatio;\n        this.renderedResolution = renderedResolution;\n        this.coordinateToVectorPixelTransform_ = compose(this.coordinateToVectorPixelTransform_, width / 2, height / 2, 1 / renderedResolution, -1 / renderedResolution, 0, -viewState.center[0], -viewState.center[1]);\n      });\n      image.load();\n    }\n    if (this.image) {\n      this.renderedPixelToCoordinateTransform_ = frameState.pixelToCoordinateTransform.slice();\n    }\n    return !!this.image;\n  }\n\n  /**\n   * @override\n   */\n  preRender() {}\n\n  /**\n   * @override\n   */\n  postRender() {}\n\n  /**\n   */\n  renderDeclutter() {}\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   * @override\n   */\n  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {\n    if (this.vectorRenderer_) {\n      return this.vectorRenderer_.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches);\n    }\n    return super.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches);\n  }\n}\nexport default CanvasVectorImageLayerRenderer;", "/**\n * @module ol/layer/VectorImage\n */\nimport BaseVectorLayer from './BaseVector.js';\nimport CanvasVectorImageLayerRenderer from '../renderer/canvas/VectorImageLayer.js';\n\n/**\n * @template {import(\"../source/Vector.js\").default<FeatureType>} [VectorSourceType=import(\"../source/Vector.js\").default<*>]\n * @template {import('../Feature.js').FeatureLike} [FeatureType=import(\"./BaseVector.js\").ExtractedFeatureType<VectorSourceType>]\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {import(\"../render.js\").OrderFunction} [renderOrder] Render order. Function to be used when sorting\n * features before rendering. By default features are drawn in the order that they are created. Use\n * `null` to avoid the sort, but get an undefined draw order.\n * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the\n * renderer when getting features from the vector source for the rendering or hit-detection.\n * Recommended value: the size of the largest symbol, line width or label.\n * @property {VectorSourceType} [source] Source.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use [map.addLayer()]{@link import(\"../Map.js\").default#addLayer}.\n * @property {boolean|string|number} [declutter=false] Declutter images and text on this layer. Any truthy value will enable\n * decluttering. The priority is defined by the `zIndex` of the style and the render order of features. Higher z-index means higher\n * priority. Within the same z-index, a feature rendered before another has higher priority. Items will\n * not be decluttered against or together with items on other layers with the same `declutter` value. If\n * that is needed, use {@link import(\"../layer/Vector.js\").default} instead.\n * @property {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike|null} [style] Layer style. When set to `null`, only\n * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style\n * which will be used if this is not set.\n * @property {import(\"./Base.js\").BackgroundColor} [background] Background color for the layer. If not specified, no background\n * will be rendered.\n * @property {number} [imageRatio=1] Ratio by which the rendered extent should be larger than the\n * viewport extent. A larger ratio avoids cut images during panning, but will cause a decrease in performance.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * Vector data is rendered client-side, to an image. This layer type provides great performance\n * during panning and zooming, but point symbols and texts are always rotated with the view and\n * pixels are scaled during zoom animations. For more accurate rendering of vector data, use\n * {@link module:ol/layer/Vector~VectorLayer} instead.\n *\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Vector.js\").default<FeatureType>} [VectorSourceType=import(\"../source/Vector.js\").default<*>]\n * @template {import('../Feature.js').FeatureLike} [FeatureType=import(\"./BaseVector.js\").ExtractedFeatureType<VectorSourceType>]\n * @extends {BaseVectorLayer<FeatureType, VectorSourceType, CanvasVectorImageLayerRenderer>}\n * @api\n */\nclass VectorImageLayer extends BaseVectorLayer {\n  /**\n   * @param {Options<VectorSourceType, FeatureType>} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n    const baseOptions = Object.assign({}, options);\n    delete baseOptions.imageRatio;\n    super(baseOptions);\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.imageRatio_ = options.imageRatio !== undefined ? options.imageRatio : 1;\n  }\n\n  /**\n   * @return {number} Ratio between rendered extent size and viewport extent size.\n   */\n  getImageRatio() {\n    return this.imageRatio_;\n  }\n\n  /**\n   * @override\n   */\n  createRenderer() {\n    return new CanvasVectorImageLayerRenderer(this);\n  }\n}\nexport default VectorImageLayer;", "/**\n * @module ol/layer/WebGLPoints\n */\nimport Layer from './Layer.js';\nimport WebGLPointsLayerRenderer from '../renderer/webgl/PointsLayer.js';\nimport { parseLiteralStyle } from '../webgl/styleparser.js';\n\n/**\n * @template {import(\"../source/Vector.js\").default<import('../Feature').FeatureLike>} VectorSourceType\n * @typedef {Object} Options\n * @property {import('../style/webgl.js').WebGLStyle} style Literal style to apply to the layer features.\n * @property {import('../style/flat.js').StyleVariables} [variables] Style variables. Each variable must hold a literal value (not\n * an expression). These variables can be used as {@link import(\"../expr/expression.js\").ExpressionValue expressions} in the styles properties\n * using the `['var', 'varName']` operator.\n * To update style variables, use the {@link import(\"./WebGLPoints.js\").default#updateStyleVariables} method.\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {VectorSourceType} [source] Point source.\n * @property {boolean} [disableHitDetection=false] Setting this to true will provide a slight performance boost, but will\n * prevent all hit detection on the layer.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * Layer optimized for rendering large point datasets. Takes a `style` property which\n * is a serializable JSON object describing how the layer should be rendered.\n *\n * Here are a few samples of literal style objects:\n * ```js\n * const style = {\n *   'circle-radius': 8,\n *   'circle-fill-color': '#33AAFF',\n *   'circle-opacity': 0.9\n * }\n * ```\n *\n * ```js\n * const style = {\n *   'icon-src': '../static/exclamation-mark.png',\n *   'icon-offset': [0, 12],\n *   'icon-width': 4,\n *   'icon-height': 8\n * }\n * ```\n *\n * **Important: a `WebGLPoints` layer must be manually disposed when removed, otherwise the underlying WebGL context\n * will not be garbage collected.**\n *\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Vector.js\").default<import('../Feature').FeatureLike>} VectorSourceType\n * @extends {Layer<VectorSourceType, WebGLPointsLayerRenderer>}\n * @fires import(\"../render/Event.js\").RenderEvent#prerender\n * @fires import(\"../render/Event.js\").RenderEvent#postrender\n */\nclass WebGLPointsLayer extends Layer {\n  /**\n   * @param {Options<VectorSourceType>} options Options.\n   */\n  constructor(options) {\n    const baseOptions = Object.assign({}, options);\n    super(baseOptions);\n\n    /**\n     * @type {import('../style/flat.js').StyleVariables}\n     * @private\n     */\n    this.styleVariables_ = options.variables || {};\n\n    /**\n     * @private\n     * @type {import('../webgl/styleparser.js').StyleParseResult}\n     */\n    this.parseResult_ = parseLiteralStyle(options.style, this.styleVariables_);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hitDetectionDisabled_ = !!options.disableHitDetection;\n  }\n\n  /**\n   * @override\n   */\n  createRenderer() {\n    const attributes = Object.keys(this.parseResult_.attributes).map(name => ({\n      name,\n      ...this.parseResult_.attributes[name]\n    }));\n    return new WebGLPointsLayerRenderer(this, {\n      vertexShader: this.parseResult_.builder.getSymbolVertexShader(),\n      fragmentShader: this.parseResult_.builder.getSymbolFragmentShader(),\n      hitDetectionEnabled: !this.hitDetectionDisabled_,\n      uniforms: this.parseResult_.uniforms,\n      attributes: (/** @type {Array<import('../renderer/webgl/PointsLayer.js').CustomAttribute>} */\n      attributes)\n    });\n  }\n\n  /**\n   * Update any variables used by the layer style and trigger a re-render.\n   * @param {Object<string, number>} variables Variables to update.\n   */\n  updateStyleVariables(variables) {\n    Object.assign(this.styleVariables_, variables);\n    this.changed();\n  }\n}\nexport default WebGLPointsLayer;", "/**\n * @module ol/render/webgl/MixedGeometryBatch\n */\nimport RenderFeature from '../../render/Feature.js';\nimport { getUid } from '../../util.js';\nimport { inflateEnds } from '../../geom/flat/orient.js';\n\n/**\n * @typedef {import(\"../../Feature.js\").default} Feature\n */\n/**\n * @typedef {import(\"../../geom/Geometry.js\").Type} GeometryType\n */\n\n/**\n * @typedef {Object} GeometryBatchItem Object that holds a reference to a feature as well as the raw coordinates of its various geometries\n * @property {Feature|RenderFeature} feature Feature\n * @property {Array<Array<number>>} flatCoordss Array of flat coordinates arrays, one for each geometry related to the feature\n * @property {number} [verticesCount] Only defined for linestring and polygon batches\n * @property {number} [ringsCount] Only defined for polygon batches\n * @property {Array<Array<number>>} [ringsVerticesCounts] Array of vertices counts in each ring for each geometry; only defined for polygons batches\n * @property {number} [ref] The reference in the global batch (used for hit detection)\n */\n\n/**\n * @typedef {PointGeometryBatch|LineStringGeometryBatch|PolygonGeometryBatch} GeometryBatch\n */\n\n/**\n * @typedef {Object} PolygonGeometryBatch A geometry batch specific to polygons\n * @property {Object<string, GeometryBatchItem>} entries Dictionary of all entries in the batch with associated computed values.\n * One entry corresponds to one feature. Key is feature uid.\n * @property {number} geometriesCount Amount of geometries in the batch.\n * @property {number} verticesCount Amount of vertices from geometries in the batch.\n * @property {number} ringsCount How many outer and inner rings in this batch.\n */\n\n/**\n * @typedef {Object} LineStringGeometryBatch A geometry batch specific to lines\n * @property {Object<string, GeometryBatchItem>} entries Dictionary of all entries in the batch with associated computed values.\n * One entry corresponds to one feature. Key is feature uid.\n * @property {number} geometriesCount Amount of geometries in the batch.\n * @property {number} verticesCount Amount of vertices from geometries in the batch.\n */\n\n/**\n * @typedef {Object} PointGeometryBatch A geometry batch specific to points\n * @property {Object<string, GeometryBatchItem>} entries Dictionary of all entries in the batch with associated computed values.\n * One entry corresponds to one feature. Key is feature uid.\n * @property {number} geometriesCount Amount of geometries in the batch.\n */\n\n/**\n * @classdesc This class is used to group several geometries of various types together for faster rendering.\n * Three inner batches are maintained for polygons, lines and points. Each time a feature is added, changed or removed\n * from the batch, these inner batches are modified accordingly in order to keep them up-to-date.\n *\n * A feature can be present in several inner batches, for example a polygon geometry will be present in the polygon batch\n * and its linear rings will be present in the line batch. Multi geometries are also broken down into individual geometries\n * and added to the corresponding batches in a recursive manner.\n *\n * Corresponding {@link module:ol/render/webgl/BatchRenderer} instances are then used to generate the render instructions\n * and WebGL buffers (vertices and indices) for each inner batches; render instructions are stored on the inner batches,\n * alongside the transform used to convert world coords to screen coords at the time these instructions were generated.\n * The resulting WebGL buffers are stored on the batches as well.\n *\n * An important aspect of geometry batches is that there is no guarantee that render instructions and WebGL buffers\n * are synchronized, i.e. render instructions can describe a new state while WebGL buffers might not have been written yet.\n * This is why two world-to-screen transforms are stored on each batch: one for the render instructions and one for\n * the WebGL buffers.\n */\nclass MixedGeometryBatch {\n  constructor() {\n    /**\n     * @private\n     */\n    this.globalCounter_ = 0;\n\n    /**\n     * Refs are used as keys for hit detection.\n     * @type {Map<number, Feature|RenderFeature>}\n     * @private\n     */\n    this.refToFeature_ = new Map();\n\n    /**\n     * Features are split in \"entries\", which are individual geometries. We use the following map to share a single ref for all those entries.\n     * @type {Map<string, number>}\n     * @private\n     */\n    this.uidToRef_ = new Map();\n\n    /**\n     * The precision in WebGL shaders is limited.\n     * To keep the refs as small as possible we maintain an array of returned references.\n     * @type {Array<number>}\n     * @private\n     */\n    this.freeGlobalRef_ = [];\n\n    /**\n     * @type {PolygonGeometryBatch}\n     */\n    this.polygonBatch = {\n      entries: {},\n      geometriesCount: 0,\n      verticesCount: 0,\n      ringsCount: 0\n    };\n\n    /**\n     * @type {PointGeometryBatch}\n     */\n    this.pointBatch = {\n      entries: {},\n      geometriesCount: 0\n    };\n\n    /**\n     * @type {LineStringGeometryBatch}\n     */\n    this.lineStringBatch = {\n      entries: {},\n      geometriesCount: 0,\n      verticesCount: 0\n    };\n  }\n\n  /**\n   * @param {Array<Feature|RenderFeature>} features Array of features to add to the batch\n   * @param {import(\"../../proj.js\").TransformFunction} [projectionTransform] Projection transform.\n   */\n  addFeatures(features, projectionTransform) {\n    for (let i = 0; i < features.length; i++) {\n      this.addFeature(features[i], projectionTransform);\n    }\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature to add to the batch\n   * @param {import(\"../../proj.js\").TransformFunction} [projectionTransform] Projection transform.\n   */\n  addFeature(feature, projectionTransform) {\n    let geometry = feature.getGeometry();\n    if (!geometry) {\n      return;\n    }\n    if (projectionTransform) {\n      geometry = geometry.clone();\n      geometry.applyTransform(projectionTransform);\n    }\n    this.addGeometry_(geometry, feature);\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature\n   * @return {GeometryBatchItem|void} the cleared entry\n   * @private\n   */\n  clearFeatureEntryInPointBatch_(feature) {\n    const featureUid = getUid(feature);\n    const entry = this.pointBatch.entries[featureUid];\n    if (!entry) {\n      return;\n    }\n    this.pointBatch.geometriesCount -= entry.flatCoordss.length;\n    delete this.pointBatch.entries[featureUid];\n    return entry;\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature\n   * @return {GeometryBatchItem|void} the cleared entry\n   * @private\n   */\n  clearFeatureEntryInLineStringBatch_(feature) {\n    const featureUid = getUid(feature);\n    const entry = this.lineStringBatch.entries[featureUid];\n    if (!entry) {\n      return;\n    }\n    this.lineStringBatch.verticesCount -= entry.verticesCount;\n    this.lineStringBatch.geometriesCount -= entry.flatCoordss.length;\n    delete this.lineStringBatch.entries[featureUid];\n    return entry;\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature\n   * @return {GeometryBatchItem|void} the cleared entry\n   * @private\n   */\n  clearFeatureEntryInPolygonBatch_(feature) {\n    const featureUid = getUid(feature);\n    const entry = this.polygonBatch.entries[featureUid];\n    if (!entry) {\n      return;\n    }\n    this.polygonBatch.verticesCount -= entry.verticesCount;\n    this.polygonBatch.ringsCount -= entry.ringsCount;\n    this.polygonBatch.geometriesCount -= entry.flatCoordss.length;\n    delete this.polygonBatch.entries[featureUid];\n    return entry;\n  }\n\n  /**\n   * @param {import(\"../../geom.js\").Geometry|RenderFeature} geometry Geometry\n   * @param {Feature|RenderFeature} feature Feature\n   * @private\n   */\n  addGeometry_(geometry, feature) {\n    const type = geometry.getType();\n    switch (type) {\n      case 'GeometryCollection':\n        {\n          const geometries = /** @type {import(\"../../geom.js\").GeometryCollection} */geometry.getGeometriesArray();\n          for (const geometry of geometries) {\n            this.addGeometry_(geometry, feature);\n          }\n          break;\n        }\n      case 'MultiPolygon':\n        {\n          const multiPolygonGeom = /** @type {import(\"../../geom.js\").MultiPolygon} */geometry;\n          this.addCoordinates_(type, multiPolygonGeom.getFlatCoordinates(), multiPolygonGeom.getEndss(), feature, getUid(feature), multiPolygonGeom.getStride());\n          break;\n        }\n      case 'MultiLineString':\n        {\n          const multiLineGeom = /** @type {import(\"../../geom.js\").MultiLineString|RenderFeature} */\n          geometry;\n          this.addCoordinates_(type, multiLineGeom.getFlatCoordinates(), multiLineGeom.getEnds(), feature, getUid(feature), multiLineGeom.getStride());\n          break;\n        }\n      case 'MultiPoint':\n        {\n          const multiPointGeom = /** @type {import(\"../../geom.js\").MultiPoint|RenderFeature} */\n          geometry;\n          this.addCoordinates_(type, multiPointGeom.getFlatCoordinates(), null, feature, getUid(feature), multiPointGeom.getStride());\n          break;\n        }\n      case 'Polygon':\n        {\n          const polygonGeom = /** @type {import(\"../../geom.js\").Polygon|RenderFeature} */\n          geometry;\n          this.addCoordinates_(type, polygonGeom.getFlatCoordinates(), polygonGeom.getEnds(), feature, getUid(feature), polygonGeom.getStride());\n          break;\n        }\n      case 'Point':\n        {\n          const pointGeom = /** @type {import(\"../../geom.js\").Point} */\n          geometry;\n          this.addCoordinates_(type, pointGeom.getFlatCoordinates(), null, feature, getUid(feature), pointGeom.getStride());\n          break;\n        }\n      case 'LineString':\n      case 'LinearRing':\n        {\n          const lineGeom = /** @type {import(\"../../geom.js\").LineString} */\n          geometry;\n          const stride = lineGeom.getStride();\n          this.addCoordinates_(type, lineGeom.getFlatCoordinates(), null, feature, getUid(feature), stride, lineGeom.getLayout?.());\n          break;\n        }\n      default:\n      // pass\n    }\n  }\n\n  /**\n   * @param {GeometryType} type Geometry type\n   * @param {Array<number>} flatCoords Flat coordinates\n   * @param {Array<number> | Array<Array<number>> | null} ends Coordinate ends\n   * @param {Feature|RenderFeature} feature Feature\n   * @param {string} featureUid Feature uid\n   * @param {number} stride Stride\n   * @param {import('../../geom/Geometry.js').GeometryLayout} [layout] Layout\n   * @private\n   */\n  addCoordinates_(type, flatCoords, ends, feature, featureUid, stride, layout) {\n    /** @type {number} */\n    let verticesCount;\n    switch (type) {\n      case 'MultiPolygon':\n        {\n          const multiPolygonEndss = /** @type {Array<Array<number>>} */ends;\n          for (let i = 0, ii = multiPolygonEndss.length; i < ii; i++) {\n            let polygonEnds = multiPolygonEndss[i];\n            const prevPolygonEnds = i > 0 ? multiPolygonEndss[i - 1] : null;\n            const startIndex = prevPolygonEnds ? prevPolygonEnds[prevPolygonEnds.length - 1] : 0;\n            const endIndex = polygonEnds[polygonEnds.length - 1];\n            polygonEnds = startIndex > 0 ? polygonEnds.map(end => end - startIndex) : polygonEnds;\n            this.addCoordinates_('Polygon', flatCoords.slice(startIndex, endIndex), polygonEnds, feature, featureUid, stride, layout);\n          }\n          break;\n        }\n      case 'MultiLineString':\n        {\n          const multiLineEnds = /** @type {Array<number>} */ends;\n          for (let i = 0, ii = multiLineEnds.length; i < ii; i++) {\n            const startIndex = i > 0 ? multiLineEnds[i - 1] : 0;\n            this.addCoordinates_('LineString', flatCoords.slice(startIndex, multiLineEnds[i]), null, feature, featureUid, stride, layout);\n          }\n          break;\n        }\n      case 'MultiPoint':\n        for (let i = 0, ii = flatCoords.length; i < ii; i += stride) {\n          this.addCoordinates_('Point', flatCoords.slice(i, i + 2), null, feature, featureUid, null, null);\n        }\n        break;\n      case 'Polygon':\n        {\n          const polygonEnds = /** @type {Array<number>} */ends;\n          if (feature instanceof RenderFeature) {\n            const multiPolygonEnds = inflateEnds(flatCoords, polygonEnds);\n            if (multiPolygonEnds.length > 1) {\n              this.addCoordinates_('MultiPolygon', flatCoords, multiPolygonEnds, feature, featureUid, stride, layout);\n              return;\n            }\n          }\n          if (!this.polygonBatch.entries[featureUid]) {\n            this.polygonBatch.entries[featureUid] = this.addRefToEntry_(featureUid, {\n              feature: feature,\n              flatCoordss: [],\n              verticesCount: 0,\n              ringsCount: 0,\n              ringsVerticesCounts: []\n            });\n          }\n          verticesCount = flatCoords.length / stride;\n          const ringsCount = ends.length;\n          const ringsVerticesCount = ends.map((end, ind, arr) => ind > 0 ? (end - arr[ind - 1]) / stride : end / stride);\n          this.polygonBatch.verticesCount += verticesCount;\n          this.polygonBatch.ringsCount += ringsCount;\n          this.polygonBatch.geometriesCount++;\n          this.polygonBatch.entries[featureUid].flatCoordss.push(getFlatCoordinatesXY(flatCoords, stride));\n          this.polygonBatch.entries[featureUid].ringsVerticesCounts.push(ringsVerticesCount);\n          this.polygonBatch.entries[featureUid].verticesCount += verticesCount;\n          this.polygonBatch.entries[featureUid].ringsCount += ringsCount;\n          for (let i = 0, ii = polygonEnds.length; i < ii; i++) {\n            const startIndex = i > 0 ? polygonEnds[i - 1] : 0;\n            this.addCoordinates_('LinearRing', flatCoords.slice(startIndex, polygonEnds[i]), null, feature, featureUid, stride, layout);\n          }\n          break;\n        }\n      case 'Point':\n        if (!this.pointBatch.entries[featureUid]) {\n          this.pointBatch.entries[featureUid] = this.addRefToEntry_(featureUid, {\n            feature: feature,\n            flatCoordss: []\n          });\n        }\n        this.pointBatch.geometriesCount++;\n        this.pointBatch.entries[featureUid].flatCoordss.push(flatCoords);\n        break;\n      case 'LineString':\n      case 'LinearRing':\n        if (!this.lineStringBatch.entries[featureUid]) {\n          this.lineStringBatch.entries[featureUid] = this.addRefToEntry_(featureUid, {\n            feature: feature,\n            flatCoordss: [],\n            verticesCount: 0\n          });\n        }\n        verticesCount = flatCoords.length / stride;\n        this.lineStringBatch.verticesCount += verticesCount;\n        this.lineStringBatch.geometriesCount++;\n        this.lineStringBatch.entries[featureUid].flatCoordss.push(getFlatCoordinatesXYM(flatCoords, stride, layout));\n        this.lineStringBatch.entries[featureUid].verticesCount += verticesCount;\n        break;\n      default:\n      // pass\n    }\n  }\n\n  /**\n   * @param {string} featureUid Feature uid\n   * @param {GeometryBatchItem} entry The entry to add\n   * @return {GeometryBatchItem} the added entry\n   * @private\n   */\n  addRefToEntry_(featureUid, entry) {\n    const currentRef = this.uidToRef_.get(featureUid);\n\n    // the ref starts at 1 to distinguish from white color (no feature)\n    const ref = currentRef || this.freeGlobalRef_.pop() || ++this.globalCounter_;\n    entry.ref = ref;\n    if (!currentRef) {\n      this.refToFeature_.set(ref, entry.feature);\n      this.uidToRef_.set(featureUid, ref);\n    }\n    return entry;\n  }\n\n  /**\n   * Return a ref to the pool of available refs.\n   * @param {number} ref the ref to return\n   * @param {string} featureUid the feature uid\n   * @private\n   */\n  returnRef_(ref, featureUid) {\n    if (!ref) {\n      throw new Error('This feature has no ref: ' + featureUid);\n    }\n    this.refToFeature_.delete(ref);\n    this.uidToRef_.delete(featureUid);\n    this.freeGlobalRef_.push(ref);\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature\n   */\n  changeFeature(feature) {\n    this.removeFeature(feature);\n    const geometry = feature.getGeometry();\n    if (!geometry) {\n      return;\n    }\n    this.addGeometry_(geometry, feature);\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature\n   */\n  removeFeature(feature) {\n    let entry;\n    entry = this.clearFeatureEntryInPointBatch_(feature) || entry;\n    entry = this.clearFeatureEntryInPolygonBatch_(feature) || entry;\n    entry = this.clearFeatureEntryInLineStringBatch_(feature) || entry;\n    if (entry) {\n      this.returnRef_(entry.ref, getUid(entry.feature));\n    }\n  }\n  clear() {\n    this.polygonBatch.entries = {};\n    this.polygonBatch.geometriesCount = 0;\n    this.polygonBatch.verticesCount = 0;\n    this.polygonBatch.ringsCount = 0;\n    this.lineStringBatch.entries = {};\n    this.lineStringBatch.geometriesCount = 0;\n    this.lineStringBatch.verticesCount = 0;\n    this.pointBatch.entries = {};\n    this.pointBatch.geometriesCount = 0;\n    this.globalCounter_ = 0;\n    this.freeGlobalRef_ = [];\n    this.refToFeature_.clear();\n    this.uidToRef_.clear();\n  }\n\n  /**\n   * Resolve the feature associated to a ref.\n   * @param {number} ref Hit detected ref\n   * @return {Feature|RenderFeature} feature\n   */\n  getFeatureFromRef(ref) {\n    return this.refToFeature_.get(ref);\n  }\n}\n\n/**\n * @param {Array<number>} flatCoords Flat coords\n * @param {number} stride Stride\n * @return {Array<number>} Flat coords with only XY components\n */\nfunction getFlatCoordinatesXY(flatCoords, stride) {\n  if (stride === 2) {\n    return flatCoords;\n  }\n  return flatCoords.filter((v, i) => i % stride < 2);\n}\n\n/**\n * @param {Array<number>} flatCoords Flat coords\n * @param {number} stride Stride\n * @param {string} layout Layout\n * @return {Array<number>} Flat coords with only XY components\n */\nfunction getFlatCoordinatesXYM(flatCoords, stride, layout) {\n  if (stride === 3 && layout === 'XYM') {\n    return flatCoords;\n  }\n  // this is XYZM layout\n  if (stride === 4) {\n    return flatCoords.filter((v, i) => i % stride !== 2);\n  }\n  // this is XYZ layout\n  if (stride === 3) {\n    return flatCoords.map((v, i) => i % stride !== 2 ? v : 0);\n  }\n  // this is XY layout\n  return new Array(flatCoords.length * 1.5).fill(0).map((v, i) => i % 3 === 2 ? 0 : flatCoords[Math.round(i / 1.5)]);\n}\nexport default MixedGeometryBatch;", "/**\n * @module ol/render/webgl/renderinstructions\n */\nimport { apply as applyTransform } from '../../transform.js';\nimport { transform2D } from '../../geom/flat/transform.js';\n\n/**\n * @param {Float32Array} renderInstructions Render instructions\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @param {import(\"./MixedGeometryBatch.js\").GeometryBatchItem} batchEntry Batch item\n * @param {number} currentIndex Current index\n * @return {number} The amount of values pushed\n */\nfunction pushCustomAttributesInRenderInstructions(renderInstructions, customAttributes, batchEntry, currentIndex) {\n  let shift = 0;\n  for (const key in customAttributes) {\n    const attr = customAttributes[key];\n    const value = attr.callback.call(batchEntry, batchEntry.feature);\n    renderInstructions[currentIndex + shift++] = value[0] ?? value;\n    if (!attr.size || attr.size === 1) {\n      continue;\n    }\n    renderInstructions[currentIndex + shift++] = value[1];\n    if (attr.size < 3) {\n      continue;\n    }\n    renderInstructions[currentIndex + shift++] = value[2];\n    if (attr.size < 4) {\n      continue;\n    }\n    renderInstructions[currentIndex + shift++] = value[3];\n  }\n  return shift;\n}\n\n/**\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @return {number} Cumulated size of all attributes\n */\nexport function getCustomAttributesSize(customAttributes) {\n  return Object.keys(customAttributes).reduce((prev, curr) => prev + (customAttributes[curr].size || 1), 0);\n}\n\n/**\n * Render instructions for lines are structured like so:\n * [ x0, y0, customAttr0, ... , xN, yN, customAttrN ]\n * @param {import(\"./MixedGeometryBatch.js\").PointGeometryBatch} batch Point geometry batch\n * @param {Float32Array} renderInstructions Render instructions\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n * @return {Float32Array} Generated render instructions\n */\nexport function generatePointRenderInstructions(batch, renderInstructions, customAttributes, transform) {\n  // here we anticipate the amount of render instructions for points:\n  // 2 instructions per vertex for position (x and y)\n  // + 1 instruction per vertex per custom attributes\n  const totalInstructionsCount = (2 + getCustomAttributesSize(customAttributes)) * batch.geometriesCount;\n  if (!renderInstructions || renderInstructions.length !== totalInstructionsCount) {\n    renderInstructions = new Float32Array(totalInstructionsCount);\n  }\n\n  // loop on features to fill the render instructions\n  const tmpCoords = [];\n  let renderIndex = 0;\n  for (const featureUid in batch.entries) {\n    const batchEntry = batch.entries[featureUid];\n    for (let i = 0, ii = batchEntry.flatCoordss.length; i < ii; i++) {\n      tmpCoords[0] = batchEntry.flatCoordss[i][0];\n      tmpCoords[1] = batchEntry.flatCoordss[i][1];\n      applyTransform(transform, tmpCoords);\n      renderInstructions[renderIndex++] = tmpCoords[0];\n      renderInstructions[renderIndex++] = tmpCoords[1];\n      renderIndex += pushCustomAttributesInRenderInstructions(renderInstructions, customAttributes, batchEntry, renderIndex);\n    }\n  }\n  return renderInstructions;\n}\n\n/**\n * Render instructions for lines are structured like so:\n * [ customAttr0, ... , customAttrN, numberOfVertices0, x0, y0, ... , xN, yN, numberOfVertices1, ... ]\n * @param {import(\"./MixedGeometryBatch.js\").LineStringGeometryBatch} batch Line String geometry batch\n * @param {Float32Array} renderInstructions Render instructions\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n * @return {Float32Array} Generated render instructions\n */\nexport function generateLineStringRenderInstructions(batch, renderInstructions, customAttributes, transform) {\n  // here we anticipate the amount of render instructions for lines:\n  // 3 instructions per vertex for position (x, y and m)\n  // + 1 instruction per line per custom attributes\n  // + 1 instruction per line (for vertices count)\n  const totalInstructionsCount = 3 * batch.verticesCount + (1 + getCustomAttributesSize(customAttributes)) * batch.geometriesCount;\n  if (!renderInstructions || renderInstructions.length !== totalInstructionsCount) {\n    renderInstructions = new Float32Array(totalInstructionsCount);\n  }\n\n  // loop on features to fill the render instructions\n  const flatCoords = [];\n  let renderIndex = 0;\n  for (const featureUid in batch.entries) {\n    const batchEntry = batch.entries[featureUid];\n    for (let i = 0, ii = batchEntry.flatCoordss.length; i < ii; i++) {\n      flatCoords.length = batchEntry.flatCoordss[i].length;\n      transform2D(batchEntry.flatCoordss[i], 0, flatCoords.length, 3, transform, flatCoords, 3);\n      renderIndex += pushCustomAttributesInRenderInstructions(renderInstructions, customAttributes, batchEntry, renderIndex);\n\n      // vertices count\n      renderInstructions[renderIndex++] = flatCoords.length / 3;\n\n      // looping on points for positions\n      for (let j = 0, jj = flatCoords.length; j < jj; j += 3) {\n        renderInstructions[renderIndex++] = flatCoords[j];\n        renderInstructions[renderIndex++] = flatCoords[j + 1];\n        renderInstructions[renderIndex++] = flatCoords[j + 2];\n      }\n    }\n  }\n  return renderInstructions;\n}\n\n/**\n * Render instructions for polygons are structured like so:\n * [ customAttr0, ..., customAttrN, numberOfRings, numberOfVerticesInRing0, ..., numberOfVerticesInRingN, x0, y0, ..., xN, yN, numberOfRings,... ]\n * @param {import(\"./MixedGeometryBatch.js\").PolygonGeometryBatch} batch Polygon geometry batch\n * @param {Float32Array} renderInstructions Render instructions\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n * @return {Float32Array} Generated render instructions\n */\nexport function generatePolygonRenderInstructions(batch, renderInstructions, customAttributes, transform) {\n  // here we anticipate the amount of render instructions for polygons:\n  // 2 instructions per vertex for position (x and y)\n  // + 1 instruction per polygon per custom attributes\n  // + 1 instruction per polygon (for vertices count in polygon)\n  // + 1 instruction per ring (for vertices count in ring)\n  const totalInstructionsCount = 2 * batch.verticesCount + (1 + getCustomAttributesSize(customAttributes)) * batch.geometriesCount + batch.ringsCount;\n  if (!renderInstructions || renderInstructions.length !== totalInstructionsCount) {\n    renderInstructions = new Float32Array(totalInstructionsCount);\n  }\n\n  // loop on features to fill the render instructions\n  const flatCoords = [];\n  let renderIndex = 0;\n  for (const featureUid in batch.entries) {\n    const batchEntry = batch.entries[featureUid];\n    for (let i = 0, ii = batchEntry.flatCoordss.length; i < ii; i++) {\n      flatCoords.length = batchEntry.flatCoordss[i].length;\n      transform2D(batchEntry.flatCoordss[i], 0, flatCoords.length, 2, transform, flatCoords);\n      renderIndex += pushCustomAttributesInRenderInstructions(renderInstructions, customAttributes, batchEntry, renderIndex);\n\n      // ring count\n      renderInstructions[renderIndex++] = batchEntry.ringsVerticesCounts[i].length;\n\n      // vertices count in each ring\n      for (let j = 0, jj = batchEntry.ringsVerticesCounts[i].length; j < jj; j++) {\n        renderInstructions[renderIndex++] = batchEntry.ringsVerticesCounts[i][j];\n      }\n\n      // looping on points for positions\n      for (let j = 0, jj = flatCoords.length; j < jj; j += 2) {\n        renderInstructions[renderIndex++] = flatCoords[j];\n        renderInstructions[renderIndex++] = flatCoords[j + 1];\n      }\n    }\n  }\n  return renderInstructions;\n}", "/**\n * @module ol/render/webgl/VectorStyleRenderer\n */\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport { ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER } from '../../webgl.js';\nimport { AttributeType } from '../../webgl/Helper.js';\nimport { WebGLWorkerMessageType } from './constants.js';\nimport { colorEncodeId } from './utils.js';\nimport { create as createTransform, makeInverse as makeInverseTransform } from '../../transform.js';\nimport { create as createWebGLWorker } from '../../worker/webgl.js';\nimport { generateLineStringRenderInstructions, generatePointRenderInstructions, generatePolygonRenderInstructions, getCustomAttributesSize } from './renderinstructions.js';\nimport { parseLiteralStyle } from '../../webgl/styleparser.js';\nconst tmpColor = [];\nconst WEBGL_WORKER = createWebGLWorker();\nlet workerMessageCounter = 0;\n\n/**\n * Names of attributes made available to the vertex shader.\n * Please note: changing these *will* break custom shaders!\n * @enum {string}\n */\nexport const Attributes = {\n  POSITION: 'a_position',\n  INDEX: 'a_index',\n  SEGMENT_START: 'a_segmentStart',\n  SEGMENT_END: 'a_segmentEnd',\n  MEASURE_START: 'a_measureStart',\n  MEASURE_END: 'a_measureEnd',\n  PARAMETERS: 'a_parameters',\n  JOIN_ANGLES: 'a_joinAngles',\n  DISTANCE: 'a_distance'\n};\n\n/**\n * @typedef {Object} AttributeDefinition A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {number} [size] Amount of numerical values composing the attribute, either 1, 2, 3 or 4; in case size is > 1, the return value\n * of the callback should be an array; if unspecified, assumed to be a single float value\n * @property {function(this:import(\"./MixedGeometryBatch.js\").GeometryBatchItem, import(\"../../Feature\").FeatureLike):number|Array<number>} callback This callback computes the numerical value of the\n * attribute for a given feature.\n */\n\n/**\n * @typedef {Object<string, AttributeDefinition>} AttributeDefinitions\n * @typedef {Object<string, import(\"../../webgl/Helper\").UniformValue>} UniformDefinitions\n */\n\n/**\n * @typedef {Object} WebGLBuffers\n * @property {Array<WebGLArrayBuffer>} polygonBuffers Array containing indices and vertices buffers for polygons\n * @property {Array<WebGLArrayBuffer>} lineStringBuffers Array containing indices and vertices buffers for line strings\n * @property {Array<WebGLArrayBuffer>} pointBuffers Array containing indices and vertices buffers for points\n * @property {import(\"../../transform.js\").Transform} invertVerticesTransform Inverse of the transform applied when generating buffers\n */\n\n/**\n * @typedef {Object} RenderInstructions\n * @property {Float32Array|null} polygonInstructions Polygon instructions; null if nothing to render\n * @property {Float32Array|null} lineStringInstructions LineString instructions; null if nothing to render\n * @property {Float32Array|null} pointInstructions Point instructions; null if nothing to render\n */\n\n/**\n * @typedef {Object} ShaderProgram An object containing both shaders (vertex and fragment)\n * @property {string} vertex Vertex shader source\n * @property {string} fragment Fragment shader source\n */\n\n/**\n * @typedef {Object} StyleShaders\n * @property {import(\"../../webgl/ShaderBuilder.js\").ShaderBuilder} builder Shader builder with the appropriate presets.\n * @property {AttributeDefinitions} [attributes] Custom attributes made available in the vertex shaders.\n * Default shaders rely on the attributes in {@link Attributes}.\n * @property {UniformDefinitions} [uniforms] Additional uniforms usable in shaders.\n */\n\n/**\n * @typedef {import('../../style/webgl.js').WebGLStyle|StyleShaders} VectorStyle\n */\n\n/**\n * @classdesc This class is responsible for:\n * 1. generate WebGL buffers according to a provided style, using a MixedGeometryBatch as input\n * 2. rendering geometries contained in said buffers\n *\n * A layer renderer will typically maintain several of these in order to have several styles rendered separately.\n *\n * A VectorStyleRenderer instance can be created either from a literal style or from shaders using either\n * `VectorStyleRenderer.fromStyle` or `VectorStyleRenderer.fromShaders`. The shaders should not be provided explicitly\n * but instead as a preconfigured ShaderBuilder instance.\n *\n * The `generateBuffers` method returns a promise resolving to WebGL buffers that are intended to be rendered by the\n * same renderer.\n */\nclass VectorStyleRenderer {\n  /**\n   * @param {VectorStyle} styleOrShaders Literal style or custom shaders\n   * @param {import('../../style/flat.js').StyleVariables} variables Style variables\n   * @param {import('../../webgl/Helper.js').default} helper Helper\n   * @param {boolean} enableHitDetection Whether to enable the hit detection (needs compatible shader)\n   */\n  constructor(styleOrShaders, variables, helper, enableHitDetection) {\n    /**\n     * @private\n     * @type {import('../../webgl/Helper.js').default}\n     */\n    this.helper_;\n\n    /**\n     * @private\n     */\n    this.hitDetectionEnabled_ = enableHitDetection;\n    let shaders = /** @type {StyleShaders} */styleOrShaders;\n    const isShaders = 'builder' in styleOrShaders;\n    if (!isShaders) {\n      const parseResult = parseLiteralStyle(/** @type {import('../../style/webgl.js').WebGLStyle} */\n      styleOrShaders, variables);\n      shaders = {\n        builder: parseResult.builder,\n        attributes: parseResult.attributes,\n        uniforms: parseResult.uniforms\n      };\n    }\n\n    /**\n     * @private\n     * @type {WebGLProgram}\n     */\n    this.fillProgram_;\n\n    /**\n     * @private\n     * @type {WebGLProgram}\n     */\n    this.strokeProgram_;\n\n    /**\n     * @private\n     * @type {WebGLProgram}\n     */\n    this.symbolProgram_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasFill_ = !!shaders.builder.getFillVertexShader();\n    if (this.hasFill_) {\n      /**\n       * @private\n       */\n      this.fillVertexShader_ = shaders.builder.getFillVertexShader();\n      /**\n       * @private\n       */\n      this.fillFragmentShader_ = shaders.builder.getFillFragmentShader();\n    }\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasStroke_ = !!shaders.builder.getStrokeVertexShader();\n    if (this.hasStroke_) {\n      /**\n       * @private\n       */\n      this.strokeVertexShader_ = shaders.builder.getStrokeVertexShader();\n      /**\n       * @private\n       */\n      this.strokeFragmentShader_ = shaders.builder.getStrokeFragmentShader();\n    }\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasSymbol_ = !!shaders.builder.getSymbolVertexShader();\n    if (this.hasSymbol_) {\n      /**\n       * @private\n       */\n      this.symbolVertexShader_ = shaders.builder.getSymbolVertexShader();\n      /**\n       * @private\n       */\n      this.symbolFragmentShader_ = shaders.builder.getSymbolFragmentShader();\n    }\n    const hitDetectionAttributes = this.hitDetectionEnabled_ ? {\n      hitColor: {\n        callback() {\n          return colorEncodeId(this.ref, tmpColor);\n        },\n        size: 4\n      }\n    } : {};\n\n    /**\n     * @private\n     */\n    this.customAttributes_ = Object.assign({}, hitDetectionAttributes, shaders.attributes);\n    /**\n     * @private\n     */\n    this.uniforms_ = shaders.uniforms;\n    const customAttributesDesc = Object.entries(this.customAttributes_).map(([name, value]) => ({\n      name: `a_${name}`,\n      size: value.size || 1,\n      type: AttributeType.FLOAT\n    }));\n    /**\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     * @private\n     */\n    this.polygonAttributesDesc_ = [{\n      name: Attributes.POSITION,\n      size: 2,\n      type: AttributeType.FLOAT\n    }, ...customAttributesDesc];\n    /**\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     * @private\n     */\n    this.lineStringAttributesDesc_ = [{\n      name: Attributes.SEGMENT_START,\n      size: 2,\n      type: AttributeType.FLOAT\n    }, {\n      name: Attributes.MEASURE_START,\n      size: 1,\n      type: AttributeType.FLOAT\n    }, {\n      name: Attributes.SEGMENT_END,\n      size: 2,\n      type: AttributeType.FLOAT\n    }, {\n      name: Attributes.MEASURE_END,\n      size: 1,\n      type: AttributeType.FLOAT\n    }, {\n      name: Attributes.JOIN_ANGLES,\n      size: 2,\n      type: AttributeType.FLOAT\n    }, {\n      name: Attributes.DISTANCE,\n      size: 1,\n      type: AttributeType.FLOAT\n    }, {\n      name: Attributes.PARAMETERS,\n      size: 1,\n      type: AttributeType.FLOAT\n    }, ...customAttributesDesc];\n    /**\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     * @private\n     */\n    this.pointAttributesDesc_ = [{\n      name: Attributes.POSITION,\n      size: 2,\n      type: AttributeType.FLOAT\n    }, {\n      name: Attributes.INDEX,\n      size: 1,\n      type: AttributeType.FLOAT\n    }, ...customAttributesDesc];\n    this.setHelper(helper);\n  }\n\n  /**\n   * @param {import('./MixedGeometryBatch.js').default} geometryBatch Geometry batch\n   * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n   * @return {Promise<WebGLBuffers>} A promise resolving to WebGL buffers\n   */\n  async generateBuffers(geometryBatch, transform) {\n    const renderInstructions = this.generateRenderInstructions_(geometryBatch, transform);\n    const [polygonBuffers, lineStringBuffers, pointBuffers] = await Promise.all([this.generateBuffersForType_(renderInstructions.polygonInstructions, 'Polygon', transform), this.generateBuffersForType_(renderInstructions.lineStringInstructions, 'LineString', transform), this.generateBuffersForType_(renderInstructions.pointInstructions, 'Point', transform)]);\n    // also return the inverse of the transform that was applied when generating buffers\n    const invertVerticesTransform = makeInverseTransform(createTransform(), transform);\n    return {\n      polygonBuffers: polygonBuffers,\n      lineStringBuffers: lineStringBuffers,\n      pointBuffers: pointBuffers,\n      invertVerticesTransform: invertVerticesTransform\n    };\n  }\n\n  /**\n   * @param {import('./MixedGeometryBatch.js').default} geometryBatch Geometry batch\n   * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n   * @return {RenderInstructions} Render instructions\n   * @private\n   */\n  generateRenderInstructions_(geometryBatch, transform) {\n    const polygonInstructions = this.hasFill_ ? generatePolygonRenderInstructions(geometryBatch.polygonBatch, new Float32Array(0), this.customAttributes_, transform) : null;\n    const lineStringInstructions = this.hasStroke_ ? generateLineStringRenderInstructions(geometryBatch.lineStringBatch, new Float32Array(0), this.customAttributes_, transform) : null;\n    const pointInstructions = this.hasSymbol_ ? generatePointRenderInstructions(geometryBatch.pointBatch, new Float32Array(0), this.customAttributes_, transform) : null;\n    return {\n      polygonInstructions,\n      lineStringInstructions,\n      pointInstructions\n    };\n  }\n\n  /**\n   * @param {Float32Array|null} renderInstructions Render instructions\n   * @param {import(\"../../geom/Geometry.js\").Type} geometryType Geometry type\n   * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n   * @return {Promise<Array<WebGLArrayBuffer>>|null} Indices buffer and vertices buffer; null if nothing to render\n   * @private\n   */\n  generateBuffersForType_(renderInstructions, geometryType, transform) {\n    if (renderInstructions === null) {\n      return null;\n    }\n    const messageId = workerMessageCounter++;\n    let messageType;\n    switch (geometryType) {\n      case 'Polygon':\n        messageType = WebGLWorkerMessageType.GENERATE_POLYGON_BUFFERS;\n        break;\n      case 'LineString':\n        messageType = WebGLWorkerMessageType.GENERATE_LINE_STRING_BUFFERS;\n        break;\n      case 'Point':\n        messageType = WebGLWorkerMessageType.GENERATE_POINT_BUFFERS;\n        break;\n      default:\n      // pass\n    }\n\n    /** @type {import('./constants.js').WebGLWorkerGenerateBuffersMessage} */\n    const message = {\n      id: messageId,\n      type: messageType,\n      renderInstructions: renderInstructions.buffer,\n      renderInstructionsTransform: transform,\n      customAttributesSize: getCustomAttributesSize(this.customAttributes_)\n    };\n    WEBGL_WORKER.postMessage(message, [renderInstructions.buffer]);\n\n    // leave ownership of render instructions\n    renderInstructions = null;\n    return new Promise(resolve => {\n      /**\n       * @param {*} event Event.\n       */\n      const handleMessage = event => {\n        const received = event.data;\n\n        // this is not the response to our request: skip\n        if (received.id !== messageId) {\n          return;\n        }\n\n        // we've received our response: stop listening\n        WEBGL_WORKER.removeEventListener('message', handleMessage);\n\n        // the helper has disposed in the meantime; the promise will not be resolved\n        if (!this.helper_.getGL()) {\n          return;\n        }\n\n        // copy & flush received buffers to GPU\n        const verticesBuffer = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW).fromArrayBuffer(received.vertexBuffer);\n        const indicesBuffer = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, DYNAMIC_DRAW).fromArrayBuffer(received.indexBuffer);\n        this.helper_.flushBufferData(verticesBuffer);\n        this.helper_.flushBufferData(indicesBuffer);\n        resolve([indicesBuffer, verticesBuffer]);\n      };\n      WEBGL_WORKER.addEventListener('message', handleMessage);\n    });\n  }\n\n  /**\n   * Render the geometries in the given buffers.\n   * @param {WebGLBuffers} buffers WebGL Buffers to draw\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state\n   * @param {function(): void} preRenderCallback This callback will be called right before drawing, and can be used to set uniforms\n   */\n  render(buffers, frameState, preRenderCallback) {\n    this.hasFill_ && this.renderInternal_(buffers.polygonBuffers[0], buffers.polygonBuffers[1], this.fillProgram_, this.polygonAttributesDesc_, frameState, preRenderCallback);\n    this.hasStroke_ && this.renderInternal_(buffers.lineStringBuffers[0], buffers.lineStringBuffers[1], this.strokeProgram_, this.lineStringAttributesDesc_, frameState, preRenderCallback);\n    this.hasSymbol_ && this.renderInternal_(buffers.pointBuffers[0], buffers.pointBuffers[1], this.symbolProgram_, this.pointAttributesDesc_, frameState, preRenderCallback);\n  }\n\n  /**\n   * @param {WebGLArrayBuffer} indicesBuffer Indices buffer\n   * @param {WebGLArrayBuffer} verticesBuffer Vertices buffer\n   * @param {WebGLProgram} program Program\n   * @param {Array<import('../../webgl/Helper.js').AttributeDescription>} attributes Attribute descriptions\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {function(): void} preRenderCallback This callback will be called right before drawing, and can be used to set uniforms\n   * @private\n   */\n  renderInternal_(indicesBuffer, verticesBuffer, program, attributes, frameState, preRenderCallback) {\n    const renderCount = indicesBuffer.getSize();\n    if (renderCount === 0) {\n      return;\n    }\n    this.helper_.useProgram(program, frameState);\n    this.helper_.bindBuffer(verticesBuffer);\n    this.helper_.bindBuffer(indicesBuffer);\n    this.helper_.enableAttributes(attributes);\n    preRenderCallback();\n    this.helper_.drawElements(0, renderCount);\n  }\n\n  /**\n   * @param {import('../../webgl/Helper.js').default} helper Helper\n   * @param {WebGLBuffers} buffers WebGL Buffers to reload if any\n   */\n  setHelper(helper, buffers = null) {\n    this.helper_ = helper;\n    if (this.hasFill_) {\n      this.fillProgram_ = this.helper_.getProgram(this.fillFragmentShader_, this.fillVertexShader_);\n    }\n    if (this.hasStroke_) {\n      this.strokeProgram_ = this.helper_.getProgram(this.strokeFragmentShader_, this.strokeVertexShader_);\n    }\n    if (this.hasSymbol_) {\n      this.symbolProgram_ = this.helper_.getProgram(this.symbolFragmentShader_, this.symbolVertexShader_);\n    }\n    this.helper_.addUniforms(this.uniforms_);\n    if (buffers) {\n      if (buffers.polygonBuffers) {\n        this.helper_.flushBufferData(buffers.polygonBuffers[0]);\n        this.helper_.flushBufferData(buffers.polygonBuffers[1]);\n      }\n      if (buffers.lineStringBuffers) {\n        this.helper_.flushBufferData(buffers.lineStringBuffers[0]);\n        this.helper_.flushBufferData(buffers.lineStringBuffers[1]);\n      }\n      if (buffers.pointBuffers) {\n        this.helper_.flushBufferData(buffers.pointBuffers[0]);\n        this.helper_.flushBufferData(buffers.pointBuffers[1]);\n      }\n    }\n  }\n}\nexport default VectorStyleRenderer;", "/**\n * @module ol/renderer/webgl/VectorLayer\n */\nimport BaseVector from '../../layer/BaseVector.js';\nimport MixedGeometryBatch from '../../render/webgl/MixedGeometryBatch.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport VectorStyleRenderer from '../../render/webgl/VectorStyleRenderer.js';\nimport ViewHint from '../../ViewHint.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport { DefaultUniform } from '../../webgl/Helper.js';\nimport { apply as applyTransform, create as createTransform, makeInverse as makeInverseTransform, multiply as multiplyTransform, setFromArray as setFromTransform, translate as translateTransform } from '../../transform.js';\nimport { assert } from '../../asserts.js';\nimport { buffer, createEmpty, equals } from '../../extent.js';\nimport { colorDecodeId } from '../../render/webgl/utils.js';\nimport { create as createMat4, fromTransform as mat4FromTransform } from '../../vec/mat4.js';\nimport { getTransformFromProjections, getUserProjection, toUserExtent, toUserResolution } from '../../proj.js';\nimport { getWorldParameters } from './worldUtil.js';\nimport { listen, unlistenByKey } from '../../events.js';\nexport const Uniforms = {\n  ...DefaultUniform,\n  RENDER_EXTENT: 'u_renderExtent',\n  // intersection of layer, source, and view extent\n  PATTERN_ORIGIN: 'u_patternOrigin',\n  GLOBAL_ALPHA: 'u_globalAlpha'\n};\n\n/**\n * @typedef {import('../../render/webgl/VectorStyleRenderer.js').VectorStyle} VectorStyle\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {VectorStyle|Array<VectorStyle>} style Vector style as literal style or shaders; can also accept an array of styles\n * @property {Object<string, number|Array<number>|string|boolean>} variables Style variables\n * @property {boolean} [disableHitDetection=false] Setting this to true will provide a slight performance boost, but will\n * prevent all hit detection on the layer.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * Experimental WebGL vector renderer. Supports polygons, lines and points:\n *  * Polygons are broken down into triangles\n *  * Lines are rendered as strips of quads\n *  * Points are rendered as quads\n *\n * You need to provide vertex and fragment shaders as well as custom attributes for each type of geometry. All shaders\n * can access the uniforms in the {@link module:ol/webgl/Helper~DefaultUniform} enum.\n * The vertex shaders can access the following attributes depending on the geometry type:\n *  * For polygons: {@link module:ol/render/webgl/PolygonBatchRenderer~Attributes}\n *  * For line strings: {@link module:ol/render/webgl/LineStringBatchRenderer~Attributes}\n *  * For points: {@link module:ol/render/webgl/PointBatchRenderer~Attributes}\n *\n * Please note that the fragment shaders output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Note: this uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n */\nclass WebGLVectorLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n   * @param {Options} options Options.\n   */\n  constructor(layer, options) {\n    const uniforms = {\n      [Uniforms.RENDER_EXTENT]: [0, 0, 0, 0],\n      [Uniforms.PATTERN_ORIGIN]: [0, 0],\n      [Uniforms.GLOBAL_ALPHA]: 1\n    };\n    super(layer, {\n      uniforms: uniforms,\n      postProcesses: options.postProcesses\n    });\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hitDetectionEnabled_ = !options.disableHitDetection;\n\n    /**\n     * @type {WebGLRenderTarget}\n     * @private\n     */\n    this.hitRenderTarget_;\n\n    /**\n     * @private\n     */\n    this.sourceRevision_ = -1;\n\n    /**\n     * @private\n     */\n    this.previousExtent_ = createEmpty();\n\n    /**\n     * This transform is updated on every frame and is the composition of:\n     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n     * - current world->screen transform\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentTransform_ = createTransform();\n\n    /**\n     * @private\n     */\n    this.tmpCoords_ = [0, 0];\n    /**\n     * @private\n     */\n    this.tmpTransform_ = createTransform();\n    /**\n     * @private\n     */\n    this.tmpMat4_ = createMat4();\n\n    /**\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentFrameStateTransform_ = createTransform();\n\n    /**\n     * @type {import('../../style/flat.js').StyleVariables}\n     * @private\n     */\n    this.styleVariables_ = {};\n\n    /**\n     * @type {Array<VectorStyle>}\n     * @private\n     */\n    this.styles_ = [];\n\n    /**\n     * @type {Array<VectorStyleRenderer>}\n     * @private\n     */\n    this.styleRenderers_ = [];\n\n    /**\n     * @type {Array<import('../../render/webgl/VectorStyleRenderer.js').WebGLBuffers>}\n     * @private\n     */\n    this.buffers_ = [];\n    this.applyOptions_(options);\n\n    /**\n     * @private\n     */\n    this.batch_ = new MixedGeometryBatch();\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.initialFeaturesAdded_ = false;\n\n    /**\n     * @private\n     * @type {Array<import(\"../../events.js\").EventsKey|null>}\n     */\n    this.sourceListenKeys_ = null;\n  }\n\n  /**\n   * @private\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  addInitialFeatures_(frameState) {\n    const source = this.getLayer().getSource();\n    const userProjection = getUserProjection();\n    let projectionTransform;\n    if (userProjection) {\n      projectionTransform = getTransformFromProjections(userProjection, frameState.viewState.projection);\n    }\n    this.batch_.addFeatures(source.getFeatures(), projectionTransform);\n    this.sourceListenKeys_ = [listen(source, VectorEventType.ADDFEATURE, this.handleSourceFeatureAdded_.bind(this, projectionTransform)), listen(source, VectorEventType.CHANGEFEATURE, this.handleSourceFeatureChanged_, this), listen(source, VectorEventType.REMOVEFEATURE, this.handleSourceFeatureDelete_, this), listen(source, VectorEventType.CLEAR, this.handleSourceFeatureClear_, this)];\n  }\n\n  /**\n   * @param {Options} options Options.\n   * @private\n   */\n  applyOptions_(options) {\n    this.styleVariables_ = options.variables;\n    this.styles_ = Array.isArray(options.style) ? options.style : [options.style];\n  }\n\n  /**\n   * @private\n   */\n  createRenderers_() {\n    this.buffers_ = [];\n    this.styleRenderers_ = this.styles_.map(style => new VectorStyleRenderer(style, this.styleVariables_, this.helper, this.hitDetectionEnabled_));\n  }\n\n  /**\n   * @override\n   */\n  reset(options) {\n    this.applyOptions_(options);\n    if (this.helper) {\n      this.createRenderers_();\n    }\n    super.reset(options);\n  }\n\n  /**\n   * @override\n   */\n  afterHelperCreated() {\n    if (this.styleRenderers_.length) {\n      // To reuse buffers\n      this.styleRenderers_.forEach((renderer, i) => renderer.setHelper(this.helper, this.buffers_[i]));\n    } else {\n      this.createRenderers_();\n    }\n    if (this.hitDetectionEnabled_) {\n      this.hitRenderTarget_ = new WebGLRenderTarget(this.helper);\n    }\n  }\n\n  /**\n   * @param {import(\"../../proj.js\").TransformFunction} projectionTransform Transform function.\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureAdded_(projectionTransform, event) {\n    const feature = event.feature;\n    this.batch_.addFeature(feature, projectionTransform);\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureChanged_(event) {\n    const feature = event.feature;\n    this.batch_.changeFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureDelete_(event) {\n    const feature = event.feature;\n    this.batch_.removeFeature(feature);\n  }\n\n  /**\n   * @private\n   */\n  handleSourceFeatureClear_() {\n    this.batch_.clear();\n  }\n\n  /**\n   * @param {import(\"../../transform.js\").Transform} batchInvertTransform Inverse of the transformation in which geometries are expressed\n   * @private\n   */\n  applyUniforms_(batchInvertTransform) {\n    // world to screen matrix\n    setFromTransform(this.tmpTransform_, this.currentFrameStateTransform_);\n    multiplyTransform(this.tmpTransform_, batchInvertTransform);\n    this.helper.setUniformMatrixValue(Uniforms.PROJECTION_MATRIX, mat4FromTransform(this.tmpMat4_, this.tmpTransform_));\n\n    // screen to world matrix\n    makeInverseTransform(this.tmpTransform_, this.tmpTransform_);\n    this.helper.setUniformMatrixValue(Uniforms.SCREEN_TO_WORLD_MATRIX, mat4FromTransform(this.tmpMat4_, this.tmpTransform_));\n\n    // pattern origin should always be [0, 0] in world coordinates\n    this.tmpCoords_[0] = 0;\n    this.tmpCoords_[1] = 0;\n    makeInverseTransform(this.tmpTransform_, batchInvertTransform);\n    applyTransform(this.tmpTransform_, this.tmpCoords_);\n    this.helper.setUniformFloatVec2(Uniforms.PATTERN_ORIGIN, this.tmpCoords_);\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState) {\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n    const [startWorld, endWorld, worldWidth] = getWorldParameters(frameState, this.getLayer());\n\n    // draw the normal canvas\n    this.helper.prepareDraw(frameState);\n    this.renderWorlds(frameState, false, startWorld, endWorld, worldWidth);\n    this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);\n    const canvas = this.helper.getCanvas();\n    if (this.hitDetectionEnabled_) {\n      this.renderWorlds(frameState, true, startWorld, endWorld, worldWidth);\n      this.hitRenderTarget_.clearCachedData();\n    }\n    this.postRender(gl, frameState);\n    return canvas;\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrameInternal(frameState) {\n    if (!this.initialFeaturesAdded_) {\n      this.addInitialFeatures_(frameState);\n      this.initialFeaturesAdded_ = true;\n    }\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    const viewState = frameState.viewState;\n    const viewNotMoving = !frameState.viewHints[ViewHint.ANIMATING] && !frameState.viewHints[ViewHint.INTERACTING];\n    const extentChanged = !equals(this.previousExtent_, frameState.extent);\n    const sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n    if (sourceChanged) {\n      this.sourceRevision_ = vectorSource.getRevision();\n    }\n    if (viewNotMoving && (extentChanged || sourceChanged)) {\n      const projection = viewState.projection;\n      const resolution = viewState.resolution;\n      const renderBuffer = layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n      const extent = buffer(frameState.extent, renderBuffer * resolution);\n      const userProjection = getUserProjection();\n      if (userProjection) {\n        vectorSource.loadFeatures(toUserExtent(extent, userProjection), toUserResolution(resolution, projection), userProjection);\n      } else {\n        vectorSource.loadFeatures(extent, resolution, projection);\n      }\n      this.ready = false;\n      const transform = this.helper.makeProjectionTransform(frameState, createTransform());\n      const generatePromises = this.styleRenderers_.map((renderer, i) => renderer.generateBuffers(this.batch_, transform).then(buffers => {\n        if (this.buffers_[i]) {\n          this.disposeBuffers(this.buffers_[i]);\n        }\n        this.buffers_[i] = buffers;\n      }));\n      Promise.all(generatePromises).then(() => {\n        this.ready = true;\n        this.getLayer().changed();\n      });\n      this.previousExtent_ = frameState.extent.slice();\n    }\n    return true;\n  }\n\n  /**\n   * Render the world, either to the main framebuffer or to the hit framebuffer\n   * @param {import(\"../../Map.js\").FrameState} frameState current frame state\n   * @param {boolean} forHitDetection whether the rendering is for hit detection\n   * @param {number} startWorld the world to render in the first iteration\n   * @param {number} endWorld the last world to render\n   * @param {number} worldWidth the width of the worlds being rendered\n   */\n  renderWorlds(frameState, forHitDetection, startWorld, endWorld, worldWidth) {\n    let world = startWorld;\n    if (forHitDetection) {\n      this.hitRenderTarget_.setSize([Math.floor(frameState.size[0] / 2), Math.floor(frameState.size[1] / 2)]);\n      this.helper.prepareDrawToRenderTarget(frameState, this.hitRenderTarget_, true);\n    }\n    do {\n      this.helper.makeProjectionTransform(frameState, this.currentFrameStateTransform_);\n      translateTransform(this.currentFrameStateTransform_, world * worldWidth, 0);\n      for (let i = 0, ii = this.styleRenderers_.length; i < ii; i++) {\n        const renderer = this.styleRenderers_[i];\n        const buffers = this.buffers_[i];\n        if (!buffers) {\n          continue;\n        }\n        renderer.render(buffers, frameState, () => {\n          this.applyUniforms_(buffers.invertVerticesTransform);\n          this.helper.applyHitDetectionUniform(forHitDetection);\n        });\n      }\n    } while (++world < endWorld);\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   * @override\n   */\n  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {\n    assert(this.hitDetectionEnabled_, '`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has been disabled using the `disableHitDetection: true` option.');\n    if (!this.styleRenderers_.length || !this.hitDetectionEnabled_) {\n      return undefined;\n    }\n    const pixel = applyTransform(frameState.coordinateToPixelTransform, coordinate.slice());\n    const data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n    const color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n    const ref = colorDecodeId(color);\n    const feature = this.batch_.getFeatureFromRef(ref);\n    if (feature) {\n      return callback(feature, this.getLayer(), null);\n    }\n    return undefined;\n  }\n\n  /**\n   * Will release a set of Webgl buffers\n   * @param {import('../../render/webgl/VectorStyleRenderer.js').WebGLBuffers} buffers Buffers\n   */\n  disposeBuffers(buffers) {\n    if (buffers.pointBuffers) {\n      buffers.pointBuffers.filter(Boolean).forEach(buffer => this.helper.deleteBuffer(buffer));\n    }\n    if (buffers.lineStringBuffers) {\n      buffers.lineStringBuffers.filter(Boolean).forEach(buffer => this.helper.deleteBuffer(buffer));\n    }\n    if (buffers.polygonBuffers) {\n      buffers.polygonBuffers.filter(Boolean).forEach(buffer => this.helper.deleteBuffer(buffer));\n    }\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    this.buffers_.forEach(buffers => {\n      this.disposeBuffers(buffers);\n    });\n    if (this.sourceListenKeys_) {\n      this.sourceListenKeys_.forEach(function (key) {\n        unlistenByKey(key);\n      });\n      this.sourceListenKeys_ = null;\n    }\n    super.disposeInternal();\n  }\n}\nexport default WebGLVectorLayerRenderer;", "/**\n * @module ol/layer/WebGLVector\n */\nimport Layer from './Layer.js';\nimport WebGLVectorLayerRenderer from '../renderer/webgl/VectorLayer.js';\n\n/***\n * @template T\n * @typedef {T extends import(\"../source/Vector.js\").default<infer U extends import(\"../Feature.js\").FeatureLike> ? U : never} ExtractedFeatureType\n */\n\n/**\n * @template {import(\"../source/Vector.js\").default<FeatureType>} [VectorSourceType=import(\"../source/Vector.js\").default<*>]\n * @template {import('../Feature.js').FeatureLike} [FeatureType=ExtractedFeatureType<VectorSourceType>]\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * FIXME: not supported yet\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {VectorSourceType} [source] Source.\n * @property {import('../style/webgl.js').WebGLStyle} style Layer style.\n * @property {import('../style/flat.js').StyleVariables} [variables] Style variables. Each variable must hold a literal value (not\n * an expression). These variables can be used as {@link import(\"../expr/expression.js\").ExpressionValue expressions} in the styles properties\n * using the `['var', 'varName']` operator.\n * To update style variables, use the {@link import(\"./WebGLVector.js\").default#updateStyleVariables} method.\n * @property {import(\"./Base.js\").BackgroundColor} [background] Background color for the layer. If not specified, no background\n * will be rendered.\n * FIXME: not supported yet\n * @property {boolean} [disableHitDetection=false] Setting this to true will provide a slight performance boost, but will\n * prevent all hit detection on the layer.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * Layer optimized for rendering large vector datasets.\n *\n * **Important: a `WebGLVector` layer must be manually disposed when removed, otherwise the underlying WebGL context\n * will not be garbage collected.**\n *\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Vector.js\").default<FeatureType>} [VectorSourceType=import(\"../source/Vector.js\").default<*>]\n * @template {import('../Feature.js').FeatureLike} [FeatureType=ExtractedFeatureType<VectorSourceType>]\n * @extends {Layer<VectorSourceType, WebGLVectorLayerRenderer>}\n */\nclass WebGLVectorLayer extends Layer {\n  /**\n   * @param {Options<VectorSourceType, FeatureType>} [options] Options.\n   */\n  constructor(options) {\n    const baseOptions = Object.assign({}, options);\n    super(baseOptions);\n\n    /**\n     * @type {import('../style/flat.js').StyleVariables}\n     * @private\n     */\n    this.styleVariables_ = options.variables || {};\n\n    /**\n     * @private\n     */\n    this.style_ = options.style;\n\n    /**\n     * @private\n     */\n    this.hitDetectionDisabled_ = !!options.disableHitDetection;\n  }\n\n  /**\n   * @override\n   */\n  createRenderer() {\n    return new WebGLVectorLayerRenderer(this, {\n      style: this.style_,\n      variables: this.styleVariables_,\n      disableHitDetection: this.hitDetectionDisabled_\n    });\n  }\n\n  /**\n   * Update any variables used by the layer style and trigger a re-render.\n   * @param {import('../style/flat.js').StyleVariables} variables Variables to update.\n   */\n  updateStyleVariables(variables) {\n    Object.assign(this.styleVariables_, variables);\n    this.changed();\n  }\n\n  /**\n   * Set the layer style.\n   * @param {import('../style/webgl.js').WebGLStyle} style Layer style.\n   */\n  setStyle(style) {\n    this.style = style;\n    this.clearRenderer();\n    this.changed();\n  }\n}\nexport default WebGLVectorLayer;"],
  "mappings": "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",
  "names": ["create", "Layer_default", "create", "equals", "tmpColor", "geometry", "create", "Layer_default", "create", "equals", "buffer", "VectorLayer_default", "VectorLayer_default"]
}
