{
  "version": 3,
  "sources": ["../../../../../../../../node_modules/ol/reproj/Tile.js"],
  "sourcesContent": ["/**\n * @module ol/reproj/Tile\n */\nimport { ERROR_THRESHOLD } from './common.js';\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport { calculateSourceExtentResolution, canvasPool, render as renderReprojected } from '../reproj.js';\nimport { clamp } from '../math.js';\nimport { getArea, getIntersection, getWidth, wrapAndSliceX } from '../extent.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport { releaseCanvas } from '../dom.js';\n\n/**\n * @typedef {function(number, number, number, number) : (import(\"../ImageTile.js\").default)} FunctionType\n */\n\n/**\n * @typedef {Object} TileOffset\n * @property {import(\"../ImageTile.js\").default} tile Tile.\n * @property {number} offset Offset.\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nclass ReprojTile extends Tile {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number} [errorThreshold] Acceptable reprojection error (in px).\n   * @param {boolean} [renderEdges] Render reprojection edges.\n   * @param {import(\"../Tile.js\").Options} [options] Tile options.\n   */\n  constructor(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, errorThreshold, renderEdges, options) {\n    super(tileCoord, TileState.IDLE, options);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<TileOffset>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.clipExtent_ = sourceProj.canWrapX() ? sourceProj.getExtent() : undefined;\n    const targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n    const limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n    const sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n    const targetResolution = targetTileGrid.getResolution(this.wrappedTileCoord_[0]);\n    const sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n    const errorThresholdInPixels = errorThreshold !== undefined ? errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n        sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      let worldWidth = 0;\n      let worldsAway = 0;\n      if (sourceProj.canWrapX()) {\n        worldWidth = getWidth(sourceProjExtent);\n        worldsAway = Math.floor((sourceExtent[0] - sourceProjExtent[0]) / worldWidth);\n      }\n      const sourceExtents = wrapAndSliceX(sourceExtent.slice(), sourceProj, true);\n      sourceExtents.forEach(extent => {\n        const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(extent, this.sourceZ_);\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n            const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n            if (tile) {\n              const offset = worldsAway * worldWidth;\n              this.sourceTiles_.push({\n                tile,\n                offset\n              });\n            }\n          }\n        }\n        ++worldsAway;\n      });\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  getImage() {\n    return this.canvas_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const sources = [];\n    this.sourceTiles_.forEach(source => {\n      const tile = source.tile;\n      if (tile && tile.getState() == TileState.LOADED) {\n        const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\n        extent[0] += source.offset;\n        extent[2] += source.offset;\n        const clipExtent = this.clipExtent_?.slice();\n        if (clipExtent) {\n          clipExtent[0] += source.offset;\n          clipExtent[2] += source.offset;\n        }\n        sources.push({\n          extent: extent,\n          clipExtent: clipExtent,\n          image: tile.getImage()\n        });\n      }\n    });\n    this.sourceTiles_.length = 0;\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const width = typeof size === 'number' ? size : size[0];\n      const height = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n      this.canvas_ = renderReprojected(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.interpolate);\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @override\n   */\n  load() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      let leftToLoad = 0;\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(({\n        tile\n      }) => {\n        const state = tile.getState();\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad++;\n          const sourceListenKey = listen(tile, EventType.CHANGE, e => {\n            const state = tile.getState();\n            if (state == TileState.LOADED || state == TileState.ERROR || state == TileState.EMPTY) {\n              unlistenByKey(sourceListenKey);\n              leftToLoad--;\n              if (leftToLoad === 0) {\n                this.unlistenSources_();\n                this.reproject_();\n              }\n            }\n          });\n          this.sourcesListenerKeys_.push(sourceListenKey);\n        }\n      });\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      } else {\n        this.sourceTiles_.forEach(function ({\n          tile\n        }, i, arr) {\n          const state = tile.getState();\n          if (state == TileState.IDLE) {\n            tile.load();\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n\n  /**\n   * Remove from the cache due to expiry\n   * @override\n   */\n  release() {\n    if (this.canvas_) {\n      releaseCanvas(this.canvas_.getContext('2d'));\n      canvasPool.push(this.canvas_);\n      this.canvas_ = null;\n    }\n    super.release();\n  }\n}\nexport default ReprojTile;"],
  "mappings": "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",
  "names": ["state", "Tile_default"]
}
